{"ast":null,"code":"/* globals chrome, navigator */\n'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar _a = require('@twilio/webrtc/lib/util'),\n    guessBrowser = _a.guessBrowser,\n    isWebRTCSupported = _a.support;\n\nvar SUPPORTED_CHROME_BASED_BROWSERS = ['edg', 'edge', 'electron', 'headlesschrome'];\nvar SUPPORTED_ANDROID_BROWSERS = ['chrome', 'firefox'];\nvar SUPPORTED_IOS_BROWSERS = ['safari']; // Currently none. Add 'brave', 'edg', and 'edge' here once we start supporting them\n\nvar SUPPORTED_MOBILE_WEBKIT_BASED_BROWSERS = [];\n/**\n * Get the top level parenthesized substrings within a given string. Unmatched\n * parentheses are ignored.\n * Ex: \"abc) (def) gh(ij) (kl (mn)o) (pqr\" => [\"(def)\", \"(ij)\", \"(kl (mn)o)\"]\n * @param {string} string\n * @returns {string[]}\n */\n\nfunction getParenthesizedSubstrings(string) {\n  var openParenthesisPositions = [];\n  var substrings = [];\n\n  for (var i = 0; i < string.length; i++) {\n    if (string[i] === '(') {\n      openParenthesisPositions.push(i);\n    } else if (string[i] === ')' && openParenthesisPositions.length > 0) {\n      var openParenthesisPosition = openParenthesisPositions.pop();\n\n      if (openParenthesisPositions.length === 0) {\n        substrings.push(string.substring(openParenthesisPosition, i + 1));\n      }\n    }\n  }\n\n  return substrings;\n}\n/**\n * Check whether the current browser is a mobile browser\n * @param {string} userAgent\n * @returns {boolean}\n */\n\n\nfunction isMobile(userAgent) {\n  userAgent = userAgent || navigator.userAgent;\n  return /Mobi/.test(userAgent);\n}\n/**\n * Check whether the current browser is non-Chromium Edge.\n * @param {string} browser\n * @returns {boolean}\n */\n\n\nfunction isNonChromiumEdge(browser) {\n  return browser === 'chrome' && /Edge/.test(navigator.userAgent) && (typeof chrome === 'undefined' || typeof chrome.runtime === 'undefined');\n}\n/**\n * Get the name of the rebranded Chromium browser, if any. Re-branded Chrome's user\n * agent has the following format:\n * <source>/<version> (<os>) <engine>/<version> (<engine_name>) Chrome/<version> [Mobile] Safari/<version>\n * @param browser\n * @returns {?string} Name of the rebranded Chrome browser, or null if the browser\n *   is either not Chrome or vanilla Chrome.\n */\n\n\nfunction rebrandedChromeBrowser(browser) {\n  // If the browser is not Chrome based, then it is not a rebranded Chrome browser.\n  if (browser !== 'chrome') {\n    return null;\n  } // Latest desktop Brave browser has a \"brave\" property in navigator.\n\n\n  if ('brave' in navigator) {\n    return 'brave';\n  } // Remove the \"(.+)\" entries from the user agent thereby retaining only the\n  // <name>[/<version>] entries.\n\n\n  var parenthesizedSubstrings = getParenthesizedSubstrings(navigator.userAgent);\n  var nameAndVersions = parenthesizedSubstrings.reduce(function (userAgent, substring) {\n    return userAgent.replace(substring, '');\n  }, navigator.userAgent); // Extract the potential browser <name>s by ignoring the first two names, which\n  // point to <source> and <engine>.\n\n  var matches = nameAndVersions.match(/[^\\s]+/g) || [];\n\n  var _a = __read(matches.map(function (nameAndVersion) {\n    return nameAndVersion.split('/')[0].toLowerCase();\n  })),\n      browserNames = _a.slice(2); // Extract the <name> that is not expected to be present in the vanilla Chrome\n  // browser, which indicates the rebranded name (ex: \"edg[e]\", \"electron\"). If null,\n  // then this is a vanilla Chrome browser.\n\n\n  return browserNames.find(function (name) {\n    return !['chrome', 'mobile', 'safari'].includes(name);\n  }) || null;\n}\n/**\n * Get the name of the mobile webkit based browser, if any.\n * @param browser\n * @returns {?string} Name of the mobile webkit based browser, or null if the browser\n *   is either not webkit based or mobile safari.\n */\n\n\nfunction mobileWebKitBrowser(browser) {\n  if (browser !== 'safari') {\n    return null;\n  }\n\n  if ('brave' in navigator) {\n    return 'brave';\n  }\n\n  return ['edge', 'edg'].find(function (name) {\n    return navigator.userAgent.toLowerCase().includes(name);\n  }) || null;\n}\n/**\n * Check if the current browser is officially supported by twilio-video.js.\n * @returns {boolean}\n */\n\n\nfunction isSupported() {\n  var browser = guessBrowser(); // NOTE (csantos): Return right away if there is no browser detected\n  // to prevent unnecessary checks which could lead to errors\n\n  if (!browser) {\n    return false;\n  }\n\n  var rebrandedChrome = rebrandedChromeBrowser(browser);\n  var mobileWebKit = mobileWebKitBrowser(browser);\n  var supportedMobileBrowsers = /android/.test(navigator.userAgent.toLowerCase()) ? SUPPORTED_ANDROID_BROWSERS : SUPPORTED_IOS_BROWSERS;\n  return !!browser && isWebRTCSupported() && (!rebrandedChrome || SUPPORTED_CHROME_BASED_BROWSERS.includes(rebrandedChrome)) && !isNonChromiumEdge(browser) && (!mobileWebKit || SUPPORTED_MOBILE_WEBKIT_BASED_BROWSERS.includes(mobileWebKit)) && (!isMobile() || supportedMobileBrowsers.includes(browser));\n}\n\nmodule.exports = isSupported;","map":{"version":3,"sources":["../../lib/util/support.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* globals chrome, navigator */\n'use strict';\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar _a = require('@twilio/webrtc/lib/util'), guessBrowser = _a.guessBrowser, isWebRTCSupported = _a.support;\nvar SUPPORTED_CHROME_BASED_BROWSERS = [\n    'edg',\n    'edge',\n    'electron',\n    'headlesschrome'\n];\nvar SUPPORTED_ANDROID_BROWSERS = [\n    'chrome',\n    'firefox'\n];\nvar SUPPORTED_IOS_BROWSERS = [\n    'safari'\n];\n// Currently none. Add 'brave', 'edg', and 'edge' here once we start supporting them\nvar SUPPORTED_MOBILE_WEBKIT_BASED_BROWSERS = [];\n/**\n * Get the top level parenthesized substrings within a given string. Unmatched\n * parentheses are ignored.\n * Ex: \"abc) (def) gh(ij) (kl (mn)o) (pqr\" => [\"(def)\", \"(ij)\", \"(kl (mn)o)\"]\n * @param {string} string\n * @returns {string[]}\n */\nfunction getParenthesizedSubstrings(string) {\n    var openParenthesisPositions = [];\n    var substrings = [];\n    for (var i = 0; i < string.length; i++) {\n        if (string[i] === '(') {\n            openParenthesisPositions.push(i);\n        }\n        else if (string[i] === ')' && openParenthesisPositions.length > 0) {\n            var openParenthesisPosition = openParenthesisPositions.pop();\n            if (openParenthesisPositions.length === 0) {\n                substrings.push(string.substring(openParenthesisPosition, i + 1));\n            }\n        }\n    }\n    return substrings;\n}\n/**\n * Check whether the current browser is a mobile browser\n * @param {string} userAgent\n * @returns {boolean}\n */\nfunction isMobile(userAgent) {\n    userAgent = userAgent || navigator.userAgent;\n    return /Mobi/.test(userAgent);\n}\n/**\n * Check whether the current browser is non-Chromium Edge.\n * @param {string} browser\n * @returns {boolean}\n */\nfunction isNonChromiumEdge(browser) {\n    return browser === 'chrome' && /Edge/.test(navigator.userAgent) && (typeof chrome === 'undefined' || typeof chrome.runtime === 'undefined');\n}\n/**\n * Get the name of the rebranded Chromium browser, if any. Re-branded Chrome's user\n * agent has the following format:\n * <source>/<version> (<os>) <engine>/<version> (<engine_name>) Chrome/<version> [Mobile] Safari/<version>\n * @param browser\n * @returns {?string} Name of the rebranded Chrome browser, or null if the browser\n *   is either not Chrome or vanilla Chrome.\n */\nfunction rebrandedChromeBrowser(browser) {\n    // If the browser is not Chrome based, then it is not a rebranded Chrome browser.\n    if (browser !== 'chrome') {\n        return null;\n    }\n    // Latest desktop Brave browser has a \"brave\" property in navigator.\n    if ('brave' in navigator) {\n        return 'brave';\n    }\n    // Remove the \"(.+)\" entries from the user agent thereby retaining only the\n    // <name>[/<version>] entries.\n    var parenthesizedSubstrings = getParenthesizedSubstrings(navigator.userAgent);\n    var nameAndVersions = parenthesizedSubstrings.reduce(function (userAgent, substring) { return userAgent.replace(substring, ''); }, navigator.userAgent);\n    // Extract the potential browser <name>s by ignoring the first two names, which\n    // point to <source> and <engine>.\n    var matches = nameAndVersions.match(/[^\\s]+/g) || [];\n    var _a = __read(matches.map(function (nameAndVersion) {\n        return nameAndVersion.split('/')[0].toLowerCase();\n    })), browserNames = _a.slice(2);\n    // Extract the <name> that is not expected to be present in the vanilla Chrome\n    // browser, which indicates the rebranded name (ex: \"edg[e]\", \"electron\"). If null,\n    // then this is a vanilla Chrome browser.\n    return browserNames.find(function (name) {\n        return !['chrome', 'mobile', 'safari'].includes(name);\n    }) || null;\n}\n/**\n * Get the name of the mobile webkit based browser, if any.\n * @param browser\n * @returns {?string} Name of the mobile webkit based browser, or null if the browser\n *   is either not webkit based or mobile safari.\n */\nfunction mobileWebKitBrowser(browser) {\n    if (browser !== 'safari') {\n        return null;\n    }\n    if ('brave' in navigator) {\n        return 'brave';\n    }\n    return ['edge', 'edg'].find(function (name) {\n        return navigator.userAgent.toLowerCase().includes(name);\n    }) || null;\n}\n/**\n * Check if the current browser is officially supported by twilio-video.js.\n * @returns {boolean}\n */\nfunction isSupported() {\n    var browser = guessBrowser();\n    // NOTE (csantos): Return right away if there is no browser detected\n    // to prevent unnecessary checks which could lead to errors\n    if (!browser) {\n        return false;\n    }\n    var rebrandedChrome = rebrandedChromeBrowser(browser);\n    var mobileWebKit = mobileWebKitBrowser(browser);\n    var supportedMobileBrowsers = /android/.test(navigator.userAgent.toLowerCase()) ?\n        SUPPORTED_ANDROID_BROWSERS : SUPPORTED_IOS_BROWSERS;\n    return !!browser\n        && isWebRTCSupported()\n        && (!rebrandedChrome || SUPPORTED_CHROME_BASED_BROWSERS.includes(rebrandedChrome))\n        && !isNonChromiumEdge(browser)\n        && (!mobileWebKit || SUPPORTED_MOBILE_WEBKIT_BASED_BROWSERS.includes(mobileWebKit))\n        && (!isMobile() || supportedMobileBrowsers.includes(browser));\n}\nmodule.exports = isSupported;\n//# sourceMappingURL=support.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/* eslint new-cap:0 */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar getUserMedia = require('@twilio/webrtc').getUserMedia;\n\nvar guessBrowser = require('@twilio/webrtc/lib/util').guessBrowser;\n\nvar _a = require('../../util'),\n    capitalize = _a.capitalize,\n    defer = _a.defer,\n    waitForSometime = _a.waitForSometime,\n    waitForEvent = _a.waitForEvent;\n\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\n\nvar detectSilentAudio = require('../../util/detectsilentaudio');\n\nvar detectSilentVideo = require('../../util/detectsilentvideo');\n\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\n\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\n\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\n\nvar MediaTrackSender = require('./sender');\n\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#stopped\n   */\n  return (\n    /** @class */\n    function (_super) {\n      __extends(LocalMediaTrack, _super);\n      /**\n       * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n       * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n       * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n       */\n\n\n      function LocalMediaTrack(mediaStreamTrack, options) {\n        var _this = this; // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers\n        // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs\n        // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.\n\n\n        var workaroundWebKitBug1208516 = guessBrowser() === 'safari' && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string';\n        options = Object.assign({\n          getUserMedia: getUserMedia,\n          isCreatedByCreateLocalTracks: false,\n          workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n          gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n        }, options);\n        var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n        var kind = mediaTrackSender.kind;\n        _this = _super.call(this, mediaTrackSender, options) || this;\n        Object.defineProperties(_this, {\n          _constraints: {\n            value: typeof options[kind] === 'object' ? options[kind] : {},\n            writable: true\n          },\n          _getUserMedia: {\n            value: options.getUserMedia\n          },\n          _gUMSilentTrackWorkaround: {\n            value: options.gUMSilentTrackWorkaround\n          },\n          _workaroundWebKitBug1208516: {\n            value: options.workaroundWebKitBug1208516\n          },\n          _workaroundWebKitBug1208516Cleanup: {\n            value: null,\n            writable: true\n          },\n          _didCallEnd: {\n            value: false,\n            writable: true\n          },\n          _isCreatedByCreateLocalTracks: {\n            value: options.isCreatedByCreateLocalTracks\n          },\n          _trackSender: {\n            value: mediaTrackSender\n          },\n          id: {\n            enumerable: true,\n            value: mediaTrackSender.id\n          },\n          isEnabled: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.enabled;\n            }\n          },\n          isStopped: {\n            enumerable: true,\n            get: function () {\n              return mediaTrackSender.readyState === 'ended';\n            }\n          }\n        }); // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n        // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n\n        if (_this._workaroundWebKitBug1208516) {\n          _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n        }\n\n        return _this;\n      }\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._end = function () {\n        if (this._didCallEnd) {\n          return;\n        }\n\n        _super.prototype._end.call(this);\n\n        this._didCallEnd = true;\n        this.emit('stopped', this);\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._initialize = function () {\n        if (this._didCallEnd) {\n          this._didCallEnd = false;\n        }\n\n        _super.prototype._initialize.call(this);\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n        var _a;\n\n        var _b = this,\n            getUserMedia = _b._getUserMedia,\n            gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround,\n            log = _b._log,\n            kind = _b.mediaStreamTrack.kind;\n\n        log.info('Re-acquiring the MediaStreamTrack');\n        log.debug('Constraints:', constraints);\n        var gUMConstraints = Object.assign({\n          audio: false,\n          video: false\n        }, (_a = {}, _a[kind] = constraints, _a));\n        var gUMPromise = this._workaroundWebKitBug1208516Cleanup ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints) : getUserMedia(gUMConstraints);\n        return gUMPromise.then(function (mediaStream) {\n          return mediaStream.getTracks()[0];\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._restart = function (constraints) {\n        var _this = this;\n\n        var log = this._log;\n        constraints = constraints || this._constraints; // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n        // without stopping it first, then a NotReadableError is raised in case of\n        // video, or the restarted audio will still be silent. Hence, we stop the\n        // MediaStreamTrack here.\n\n        this._stop();\n\n        return this._reacquireTrack(constraints).catch(function (error) {\n          log.error('Failed to re-acquire the MediaStreamTrack:', {\n            error: error,\n            constraints: constraints\n          });\n          throw error;\n        }).then(function (newMediaStreamTrack) {\n          log.info('Re-acquired the MediaStreamTrack');\n          log.debug('MediaStreamTrack:', newMediaStreamTrack);\n          _this._constraints = Object.assign({}, constraints);\n          return _this._setMediaStreamTrack(newMediaStreamTrack);\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n        var _this = this; // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n\n\n        mediaStreamTrack.enabled = this.mediaStreamTrack.enabled; // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n        // stopped, this should fire a \"stopped\" event.\n\n        this._stop(); // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n        // the processedTrack already set, we don't want to replace that.\n\n\n        return (this._unprocessedTrack ? Promise.resolve().then(function () {\n          _this._unprocessedTrack = mediaStreamTrack;\n        }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n          _this._log.warn('setMediaStreamTrack failed:', {\n            error: error,\n            mediaStreamTrack: mediaStreamTrack\n          });\n        })).then(function () {\n          _this._initialize();\n\n          _this._getAllAttachedElements().forEach(function (el) {\n            return _this._attach(el);\n          });\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      LocalMediaTrack.prototype._stop = function () {\n        this.mediaStreamTrack.stop();\n\n        this._end();\n\n        return this;\n      };\n\n      LocalMediaTrack.prototype.enable = function (enabled) {\n        enabled = typeof enabled === 'boolean' ? enabled : true;\n\n        if (enabled !== this.mediaStreamTrack.enabled) {\n          this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n\n          this.mediaStreamTrack.enabled = enabled;\n          this.emit(enabled ? 'enabled' : 'disabled', this);\n        }\n\n        return this;\n      };\n\n      LocalMediaTrack.prototype.disable = function () {\n        return this.enable(false);\n      };\n\n      LocalMediaTrack.prototype.restart = function (constraints) {\n        var _this = this;\n\n        var kind = this.kind;\n\n        if (!this._isCreatedByCreateLocalTracks) {\n          return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a' + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\") + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n        }\n\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n\n        var promise = this._restart(constraints);\n\n        if (this._workaroundWebKitBug1208516) {\n          promise = promise.finally(function () {\n            _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n          });\n        }\n\n        return promise;\n      };\n\n      LocalMediaTrack.prototype.stop = function () {\n        this._log.info('Stopping');\n\n        if (this._workaroundWebKitBug1208516Cleanup) {\n          this._workaroundWebKitBug1208516Cleanup();\n\n          this._workaroundWebKitBug1208516Cleanup = null;\n        }\n\n        return this._stop();\n      };\n\n      return LocalMediaTrack;\n    }(AudioOrVideoTrack)\n  );\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\n\n\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  var log = localMediaTrack._log,\n      kind = localMediaTrack.kind;\n  var detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n  var el = localMediaTrack._dummyEl,\n      mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n  var trackChangeInProgress = null;\n\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(function () {\n      return detectSilence(el);\n    }).then(function (isSilent) {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n\n      return isSilent;\n    }).catch(function (error) {\n      log.warn('Failed to detect silence:', error);\n    }).finally(function () {\n      // Pause the dummy element again.\n      el.pause();\n    });\n  }\n\n  function shouldReacquireTrack() {\n    var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup,\n        isStopped = localMediaTrack.isStopped,\n        muted = localMediaTrack.mediaStreamTrack.muted;\n    var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup; // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n\n    return Promise.resolve().then(function () {\n      return document.visibilityState === 'visible' && !trackChangeInProgress && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n\n  function maybeRestart() {\n    return Promise.race([waitForEvent(mediaStreamTrack, 'unmute'), waitForSometime(50)]).then(function () {\n      return shouldReacquireTrack();\n    }).then(function (shouldReacquire) {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n\n        localMediaTrack._restart().finally(function () {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        });\n      } // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n\n\n      var promise = trackChangeInProgress && trackChangeInProgress.promise || Promise.resolve();\n      return promise.finally(function () {\n        return localMediaRestartDeferreds.resolveDeferred(kind);\n      });\n    });\n  }\n\n  function onMute() {\n    var log = localMediaTrack._log,\n        kind = localMediaTrack.kind;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack); // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  } // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n\n\n  var onVisibilityChange = function (isVisible) {\n    return isVisible ? maybeRestart() : false;\n  };\n\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\n\nmodule.exports = mixinLocalMediaTrack;","map":{"version":3,"sources":["../../../lib/media/track/localmediatrack.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint new-cap:0 */\n'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar getUserMedia = require('@twilio/webrtc').getUserMedia;\nvar guessBrowser = require('@twilio/webrtc/lib/util').guessBrowser;\nvar _a = require('../../util'), capitalize = _a.capitalize, defer = _a.defer, waitForSometime = _a.waitForSometime, waitForEvent = _a.waitForEvent;\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\nvar detectSilentAudio = require('../../util/detectsilentaudio');\nvar detectSilentVideo = require('../../util/detectsilentvideo');\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nvar MediaTrackSender = require('./sender');\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n    /**\n     * A {@link LocalMediaTrack} represents audio or video that your\n     * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n     * enabled and disabled with {@link LocalMediaTrack#enable} and\n     * {@link LocalMediaTrack#disable} or stopped completely with\n     * {@link LocalMediaTrack#stop}.\n     * @emits LocalMediaTrack#stopped\n     */\n    return /** @class */ (function (_super) {\n        __extends(LocalMediaTrack, _super);\n        /**\n         * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n         * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n         * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n         */\n        function LocalMediaTrack(mediaStreamTrack, options) {\n            var _this = this;\n            // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers\n            // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs\n            // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.\n            var workaroundWebKitBug1208516 = guessBrowser() === 'safari'\n                && typeof document === 'object'\n                && typeof document.addEventListener === 'function'\n                && typeof document.visibilityState === 'string';\n            options = Object.assign({\n                getUserMedia: getUserMedia,\n                isCreatedByCreateLocalTracks: false,\n                workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n                gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n            }, options);\n            var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n            var kind = mediaTrackSender.kind;\n            _this = _super.call(this, mediaTrackSender, options) || this;\n            Object.defineProperties(_this, {\n                _constraints: {\n                    value: typeof options[kind] === 'object'\n                        ? options[kind]\n                        : {},\n                    writable: true\n                },\n                _getUserMedia: {\n                    value: options.getUserMedia\n                },\n                _gUMSilentTrackWorkaround: {\n                    value: options.gUMSilentTrackWorkaround\n                },\n                _workaroundWebKitBug1208516: {\n                    value: options.workaroundWebKitBug1208516\n                },\n                _workaroundWebKitBug1208516Cleanup: {\n                    value: null,\n                    writable: true\n                },\n                _didCallEnd: {\n                    value: false,\n                    writable: true\n                },\n                _isCreatedByCreateLocalTracks: {\n                    value: options.isCreatedByCreateLocalTracks\n                },\n                _trackSender: {\n                    value: mediaTrackSender\n                },\n                id: {\n                    enumerable: true,\n                    value: mediaTrackSender.id\n                },\n                isEnabled: {\n                    enumerable: true,\n                    get: function () {\n                        return mediaTrackSender.enabled;\n                    }\n                },\n                isStopped: {\n                    enumerable: true,\n                    get: function () {\n                        return mediaTrackSender.readyState === 'ended';\n                    }\n                }\n            });\n            // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n            // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n            if (_this._workaroundWebKitBug1208516) {\n                _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n            }\n            return _this;\n        }\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._end = function () {\n            if (this._didCallEnd) {\n                return;\n            }\n            _super.prototype._end.call(this);\n            this._didCallEnd = true;\n            this.emit('stopped', this);\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._initialize = function () {\n            if (this._didCallEnd) {\n                this._didCallEnd = false;\n            }\n            _super.prototype._initialize.call(this);\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n            var _a;\n            var _b = this, getUserMedia = _b._getUserMedia, gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround, log = _b._log, kind = _b.mediaStreamTrack.kind;\n            log.info('Re-acquiring the MediaStreamTrack');\n            log.debug('Constraints:', constraints);\n            var gUMConstraints = Object.assign({\n                audio: false,\n                video: false\n            }, (_a = {}, _a[kind] = constraints, _a));\n            var gUMPromise = this._workaroundWebKitBug1208516Cleanup\n                ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints)\n                : getUserMedia(gUMConstraints);\n            return gUMPromise.then(function (mediaStream) {\n                return mediaStream.getTracks()[0];\n            });\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._restart = function (constraints) {\n            var _this = this;\n            var log = this._log;\n            constraints = constraints || this._constraints;\n            // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n            // without stopping it first, then a NotReadableError is raised in case of\n            // video, or the restarted audio will still be silent. Hence, we stop the\n            // MediaStreamTrack here.\n            this._stop();\n            return this._reacquireTrack(constraints).catch(function (error) {\n                log.error('Failed to re-acquire the MediaStreamTrack:', { error: error, constraints: constraints });\n                throw error;\n            }).then(function (newMediaStreamTrack) {\n                log.info('Re-acquired the MediaStreamTrack');\n                log.debug('MediaStreamTrack:', newMediaStreamTrack);\n                _this._constraints = Object.assign({}, constraints);\n                return _this._setMediaStreamTrack(newMediaStreamTrack);\n            });\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n            var _this = this;\n            // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n            mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n            // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n            // stopped, this should fire a \"stopped\" event.\n            this._stop();\n            // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n            // the processedTrack already set, we don't want to replace that.\n            return (this._unprocessedTrack ? Promise.resolve().then(function () {\n                _this._unprocessedTrack = mediaStreamTrack;\n            }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n                _this._log.warn('setMediaStreamTrack failed:', { error: error, mediaStreamTrack: mediaStreamTrack });\n            })).then(function () {\n                _this._initialize();\n                _this._getAllAttachedElements().forEach(function (el) { return _this._attach(el); });\n            });\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._stop = function () {\n            this.mediaStreamTrack.stop();\n            this._end();\n            return this;\n        };\n        LocalMediaTrack.prototype.enable = function (enabled) {\n            enabled = typeof enabled === 'boolean' ? enabled : true;\n            if (enabled !== this.mediaStreamTrack.enabled) {\n                this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n                this.mediaStreamTrack.enabled = enabled;\n                this.emit(enabled ? 'enabled' : 'disabled', this);\n            }\n            return this;\n        };\n        LocalMediaTrack.prototype.disable = function () {\n            return this.enable(false);\n        };\n        LocalMediaTrack.prototype.restart = function (constraints) {\n            var _this = this;\n            var kind = this.kind;\n            if (!this._isCreatedByCreateLocalTracks) {\n                return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a'\n                    + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\")\n                    + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n            }\n            if (this._workaroundWebKitBug1208516Cleanup) {\n                this._workaroundWebKitBug1208516Cleanup();\n                this._workaroundWebKitBug1208516Cleanup = null;\n            }\n            var promise = this._restart(constraints);\n            if (this._workaroundWebKitBug1208516) {\n                promise = promise.finally(function () {\n                    _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n                });\n            }\n            return promise;\n        };\n        LocalMediaTrack.prototype.stop = function () {\n            this._log.info('Stopping');\n            if (this._workaroundWebKitBug1208516Cleanup) {\n                this._workaroundWebKitBug1208516Cleanup();\n                this._workaroundWebKitBug1208516Cleanup = null;\n            }\n            return this._stop();\n        };\n        return LocalMediaTrack;\n    }(AudioOrVideoTrack));\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n    var log = localMediaTrack._log, kind = localMediaTrack.kind;\n    var detectSilence = { audio: detectSilentAudio, video: detectSilentVideo }[kind];\n    var el = localMediaTrack._dummyEl, mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n    var trackChangeInProgress = null;\n    function checkSilence() {\n        // The dummy element is paused, so play it and then detect silence.\n        return el.play().then(function () { return detectSilence(el); }).then(function (isSilent) {\n            if (isSilent) {\n                log.warn('Silence detected');\n            }\n            else {\n                log.info('Non-silence detected');\n            }\n            return isSilent;\n        }).catch(function (error) {\n            log.warn('Failed to detect silence:', error);\n        }).finally(function () {\n            // Pause the dummy element again.\n            el.pause();\n        });\n    }\n    function shouldReacquireTrack() {\n        var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup, isStopped = localMediaTrack.isStopped, muted = localMediaTrack.mediaStreamTrack.muted;\n        var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n        // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n        // 1. The app is foregrounded, and\n        // 2. A restart is not already in progress, and\n        // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n        return Promise.resolve().then(function () {\n            return document.visibilityState === 'visible'\n                && !trackChangeInProgress\n                && (muted || isInadvertentlyStopped || checkSilence());\n        });\n    }\n    function maybeRestart() {\n        return Promise.race([\n            waitForEvent(mediaStreamTrack, 'unmute'),\n            waitForSometime(50)\n        ]).then(function () { return shouldReacquireTrack(); }).then(function (shouldReacquire) {\n            if (shouldReacquire && !trackChangeInProgress) {\n                trackChangeInProgress = defer();\n                localMediaTrack._restart().finally(function () {\n                    el = localMediaTrack._dummyEl;\n                    removeMediaStreamTrackListeners();\n                    mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n                    addMediaStreamTrackListeners();\n                    trackChangeInProgress.resolve();\n                    trackChangeInProgress = null;\n                });\n            }\n            // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n            // then this makes sure that visibility callback for phase 2 is called only\n            // after the MediaStreamTrack is re-acquired.\n            var promise = (trackChangeInProgress && trackChangeInProgress.promise) || Promise.resolve();\n            return promise.finally(function () { return localMediaRestartDeferreds.resolveDeferred(kind); });\n        });\n    }\n    function onMute() {\n        var log = localMediaTrack._log, kind = localMediaTrack.kind;\n        log.info('Muted');\n        log.debug('LocalMediaTrack:', localMediaTrack);\n        // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n        // backgrounded, and the inadvertently paused elements are played before it\n        // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n        // setting this Deferred will make sure that the inadvertently paused elements\n        // are played only after the LocalMediaTrack is unmuted.\n        //\n        // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n        //\n        localMediaRestartDeferreds.startDeferred(kind);\n    }\n    function addMediaStreamTrackListeners() {\n        mediaStreamTrack.addEventListener('ended', maybeRestart);\n        mediaStreamTrack.addEventListener('mute', onMute);\n        mediaStreamTrack.addEventListener('unmute', maybeRestart);\n    }\n    function removeMediaStreamTrackListeners() {\n        mediaStreamTrack.removeEventListener('ended', maybeRestart);\n        mediaStreamTrack.removeEventListener('mute', onMute);\n        mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n    }\n    // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n    // this ensures that we acquire media tracks before RemoteMediaTrack\n    // tries to `play` them (in phase 2). This order is important because\n    // play can fail on safari if audio is not being captured.\n    var onVisibilityChange = function (isVisible) {\n        return isVisible ? maybeRestart() : false;\n    };\n    documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n    addMediaStreamTrackListeners();\n    return function () {\n        documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n        removeMediaStreamTrackListeners();\n    };\n}\nmodule.exports = mixinLocalMediaTrack;\n//# sourceMappingURL=localmediatrack.js.map"]},"metadata":{},"sourceType":"script"}
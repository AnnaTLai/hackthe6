{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n      WriterState,\n      XMLAttribute,\n      XMLCData,\n      XMLComment,\n      XMLDTDAttList,\n      XMLDTDElement,\n      XMLDTDEntity,\n      XMLDTDNotation,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDocument,\n      XMLDocumentCB,\n      XMLElement,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLStringWriter,\n      XMLStringifier,\n      XMLText,\n      getValue,\n      isFunction,\n      isObject,\n      isPlainObject,\n      hasProp = {}.hasOwnProperty;\n  ({\n    isObject,\n    isFunction,\n    isPlainObject,\n    getValue\n  } = require('./Utility'));\n  NodeType = require('./NodeType');\n  XMLDocument = require('./XMLDocument');\n  XMLElement = require('./XMLElement');\n  XMLCData = require('./XMLCData');\n  XMLComment = require('./XMLComment');\n  XMLRaw = require('./XMLRaw');\n  XMLText = require('./XMLText');\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n  XMLDeclaration = require('./XMLDeclaration');\n  XMLDocType = require('./XMLDocType');\n  XMLDTDAttList = require('./XMLDTDAttList');\n  XMLDTDEntity = require('./XMLDTDEntity');\n  XMLDTDElement = require('./XMLDTDElement');\n  XMLDTDNotation = require('./XMLDTDNotation');\n  XMLAttribute = require('./XMLAttribute');\n  XMLStringifier = require('./XMLStringifier');\n  XMLStringWriter = require('./XMLStringWriter');\n  WriterState = require('./WriterState'); // Represents an XML builder\n\n  module.exports = XMLDocumentCB = class XMLDocumentCB {\n    // Initializes a new instance of `XMLDocumentCB`\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    constructor(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n\n      this.onDataCallback = onData || function () {};\n\n      this.onEndCallback = onEnd || function () {};\n\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    } // Creates a child element node from the given XMLNode\n    // `node` the child node\n\n\n    createChildNode(node) {\n      var att, attName, attributes, child, i, len, ref, ref1;\n\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n\n        case NodeType.Element:\n          attributes = {};\n          ref = node.attribs;\n\n          for (attName in ref) {\n            if (!hasProp.call(ref, attName)) continue;\n            att = ref[attName];\n            attributes[attName] = att.value;\n          }\n\n          this.node(node.name, attributes);\n          break;\n\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n\n      ref1 = node.children; // write child nodes recursively\n\n      for (i = 0, len = ref1.length; i < len; i++) {\n        child = ref1[i];\n        this.createChildNode(child);\n\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n\n      return this;\n    } // Creates a dummy node\n\n\n    dummy() {\n      // no-op, just return this\n      return this;\n    } // Creates a node\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n\n\n    node(name, attributes, text) {\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n\n      this.openCurrent();\n      name = getValue(name);\n\n      if (attributes == null) {\n        attributes = {};\n      }\n\n      attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n      if (!isObject(attributes)) {\n        [text, attributes] = [attributes, text];\n      }\n\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n\n      if (text != null) {\n        this.text(text);\n      }\n\n      return this;\n    } // Creates a child element node or an element type declaration when called\n    // inside the DTD\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n\n\n    element(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref, root;\n\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement(...arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref = root.children;\n\n          for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            this.createChildNode(child);\n\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n\n      return this;\n    } // Adds or modifies an attribute\n    // `name` attribute name\n    // `value` attribute value\n\n\n    attribute(name, value) {\n      var attName, attValue;\n\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n\n      if (name != null) {\n        name = getValue(name);\n      }\n\n      if (isObject(name)) {\n        // expand if object\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n\n        if (this.options.keepNullAttributes && value == null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n\n      return this;\n    } // Creates a text node\n    // `value` element text\n\n\n    text(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a CDATA node\n    // `value` element text without CDATA delimiters\n\n\n    cdata(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a comment node\n    // `value` comment text\n\n\n    comment(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Adds unescaped raw text\n    // `value` text\n\n\n    raw(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Adds a processing instruction\n    // `target` instruction target\n    // `value` instruction value\n\n\n    instruction(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n\n      if (target != null) {\n        target = getValue(target);\n      }\n\n      if (value != null) {\n        value = getValue(value);\n      }\n\n      if (Array.isArray(target)) {\n        // expand if array\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        // expand if object\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n\n      return this;\n    } // Creates the xml declaration\n    // `version` A version number string, e.g. 1.0\n    // `encoding` Encoding declaration, e.g. UTF-8\n    // `standalone` standalone document declaration: true or false\n\n\n    declaration(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates the document type declaration\n    // `root`  the name of the root node\n    // `pubID` the public identifier of the external subset\n    // `sysID` the system identifier of the external subset\n\n\n    doctype(root, pubID, sysID) {\n      this.openCurrent();\n\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    } // Creates an element type declaration\n    // `name` element name\n    // `value` element content (defaults to #PCDATA)\n\n\n    dtdElement(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates an attribute declaration\n    // `elementName` the name of the element containing this attribute\n    // `attributeName` attribute name\n    // `attributeType` type of the attribute (defaults to CDATA)\n    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n    //                    #DEFAULT) (defaults to #IMPLIED)\n    // `defaultValue` default value of the attribute\n    //                (only used for #FIXED or #DEFAULT)\n\n\n    attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a general entity declaration\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    // `value.nData` notation declaration\n\n\n    entity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a parameter entity declaration\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n\n\n    pEntity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Creates a NOTATION declaration\n    // `name` the name of the notation\n    // `value` an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n\n\n    notation(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    } // Gets the parent node\n\n\n    up() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    } // Ends the document\n\n\n    end() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n\n      return this.onEnd();\n    } // Opens the current parent node\n\n\n    openCurrent() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    } // Writes the opening tag of the current node or the entire node if it has\n    // no child nodes\n\n\n    openNode(node) {\n      var att, chunk, name, ref;\n\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n\n        chunk = '';\n\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref = node.attribs;\n\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName; // external identifier\n\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          } // internal subset\n\n\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    } // Writes the closing tag of the current node\n\n\n    closeNode(node) {\n      var chunk;\n\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    } // Called when a new chunk of XML is output\n    // `chunk` a string containing the XML chunk\n    // `level` current indentation level\n\n\n    onData(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    } // Called when the XML document is completed\n\n\n    onEnd() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    } // Returns debug string\n\n\n    debugInfo(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    } // Node aliases\n\n\n    ele() {\n      return this.element(...arguments);\n    }\n\n    nod(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    txt(value) {\n      return this.text(value);\n    }\n\n    dat(value) {\n      return this.cdata(value);\n    }\n\n    com(value) {\n      return this.comment(value);\n    }\n\n    ins(target, value) {\n      return this.instruction(target, value);\n    }\n\n    dec(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    }\n\n    dtd(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    }\n\n    e(name, attributes, text) {\n      return this.element(name, attributes, text);\n    }\n\n    n(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    t(value) {\n      return this.text(value);\n    }\n\n    d(value) {\n      return this.cdata(value);\n    }\n\n    c(value) {\n      return this.comment(value);\n    }\n\n    r(value) {\n      return this.raw(value);\n    }\n\n    i(target, value) {\n      return this.instruction(target, value);\n    } // Attribute aliases\n\n\n    att() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    a() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    } // DTD aliases\n    // att() and ele() are defined above\n\n\n    ent(name, value) {\n      return this.entity(name, value);\n    }\n\n    pent(name, value) {\n      return this.pEntity(name, value);\n    }\n\n    not(name, value) {\n      return this.notation(name, value);\n    }\n\n  };\n}).call(this);","map":{"version":3,"sources":["/Users/tony_niu/Visual Studio/Twilio/twilio-video-starter-kit/src/token-service/node_modules/xmlbuilder/lib/XMLDocumentCB.js"],"names":["NodeType","WriterState","XMLAttribute","XMLCData","XMLComment","XMLDTDAttList","XMLDTDElement","XMLDTDEntity","XMLDTDNotation","XMLDeclaration","XMLDocType","XMLDocument","XMLDocumentCB","XMLElement","XMLProcessingInstruction","XMLRaw","XMLStringWriter","XMLStringifier","XMLText","getValue","isFunction","isObject","isPlainObject","hasProp","hasOwnProperty","require","module","exports","constructor","options","onData","onEnd","writerOptions","name","type","Document","writer","filterOptions","stringify","onDataCallback","onEndCallback","currentNode","currentLevel","openTags","documentStarted","documentCompleted","root","createChildNode","node","att","attName","attributes","child","i","len","ref","ref1","CData","cdata","value","Comment","comment","Element","attribs","call","Dummy","dummy","Raw","raw","Text","text","ProcessingInstruction","instruction","target","Error","children","length","up","debugInfo","openCurrent","element","oldValidationFlag","DocType","dtdElement","arguments","Array","isArray","noValidation","attribute","attValue","apply","keepNullAttributes","insTarget","insValue","processingInstruction","declaration","version","encoding","standalone","doctype","pubID","sysID","rootNodeName","attList","elementName","attributeName","attributeType","defaultValueType","defaultValue","dtdAttList","entity","dtdEntity","pEntity","notation","dtdNotation","closeNode","openNode","end","chunk","isOpen","state","OpenTag","indent","endline","InsideTag","CloseTag","isClosed","None","level","ele","nod","txt","dat","com","ins","dec","dtd","e","n","t","d","c","r","a","ent","pent","not"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject,\n    hasProp = {}.hasOwnProperty;\n\n  ({isObject, isFunction, isPlainObject, getValue} = require('./Utility'));\n\n  NodeType = require('./NodeType');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLElement = require('./XMLElement');\n\n  XMLCData = require('./XMLCData');\n\n  XMLComment = require('./XMLComment');\n\n  XMLRaw = require('./XMLRaw');\n\n  XMLText = require('./XMLText');\n\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n\n  XMLDeclaration = require('./XMLDeclaration');\n\n  XMLDocType = require('./XMLDocType');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  XMLAttribute = require('./XMLAttribute');\n\n  XMLStringifier = require('./XMLStringifier');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  WriterState = require('./WriterState');\n\n  // Represents an XML builder\n  module.exports = XMLDocumentCB = class XMLDocumentCB {\n    // Initializes a new instance of `XMLDocumentCB`\n\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    constructor(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function() {};\n      this.onEndCallback = onEnd || function() {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    // Creates a child element node from the given XMLNode\n\n    // `node` the child node\n    createChildNode(node) {\n      var att, attName, attributes, child, i, len, ref, ref1;\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n        case NodeType.Element:\n          attributes = {};\n          ref = node.attribs;\n          for (attName in ref) {\n            if (!hasProp.call(ref, attName)) continue;\n            att = ref[attName];\n            attributes[attName] = att.value;\n          }\n          this.node(node.name, attributes);\n          break;\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n      ref1 = node.children;\n      // write child nodes recursively\n      for (i = 0, len = ref1.length; i < len; i++) {\n        child = ref1[i];\n        this.createChildNode(child);\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n      return this;\n    }\n\n    // Creates a dummy node\n\n    dummy() {\n      // no-op, just return this\n      return this;\n    }\n\n    // Creates a node\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    node(name, attributes, text) {\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n      this.openCurrent();\n      name = getValue(name);\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      // swap argument order: text <-> attributes\n      if (!isObject(attributes)) {\n        [text, attributes] = [attributes, text];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    }\n\n    // Creates a child element node or an element type declaration when called\n    // inside the DTD\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    element(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref, root;\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement(...arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref = root.children;\n          for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            this.createChildNode(child);\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n      return this;\n    }\n\n    // Adds or modifies an attribute\n\n    // `name` attribute name\n    // `value` attribute value\n    attribute(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) { // expand if object\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && (value == null)) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    }\n\n    // Creates a text node\n\n    // `value` element text\n    text(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a CDATA node\n\n    // `value` element text without CDATA delimiters\n    cdata(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a comment node\n\n    // `value` comment text\n    comment(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds unescaped raw text\n\n    // `value` text\n    raw(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds a processing instruction\n\n    // `target` instruction target\n    // `value` instruction value\n    instruction(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) { // expand if array\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) { // expand if object\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n      return this;\n    }\n\n    // Creates the xml declaration\n\n    // `version` A version number string, e.g. 1.0\n    // `encoding` Encoding declaration, e.g. UTF-8\n    // `standalone` standalone document declaration: true or false\n    declaration(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates the document type declaration\n\n    // `root`  the name of the root node\n    // `pubID` the public identifier of the external subset\n    // `sysID` the system identifier of the external subset\n    doctype(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    }\n\n    // Creates an element type declaration\n\n    // `name` element name\n    // `value` element content (defaults to #PCDATA)\n    dtdElement(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates an attribute declaration\n\n    // `elementName` the name of the element containing this attribute\n    // `attributeName` attribute name\n    // `attributeType` type of the attribute (defaults to CDATA)\n    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n    //                    #DEFAULT) (defaults to #IMPLIED)\n    // `defaultValue` default value of the attribute\n    //                (only used for #FIXED or #DEFAULT)\n    attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a general entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    // `value.nData` notation declaration\n    entity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a parameter entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    pEntity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a NOTATION declaration\n\n    // `name` the name of the notation\n    // `value` an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    notation(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Gets the parent node\n    up() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    }\n\n    // Ends the document\n    end() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    }\n\n    // Opens the current parent node\n    openCurrent() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    }\n\n    // Writes the opening tag of the current node or the entire node if it has\n    // no child nodes\n    openNode(node) {\n      var att, chunk, name, ref;\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n        chunk = '';\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref = node.attribs;\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;\n          \n          // external identifier\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          }\n          \n          // internal subset\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    }\n\n    // Writes the closing tag of the current node\n    closeNode(node) {\n      var chunk;\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    }\n\n    // Called when a new chunk of XML is output\n\n    // `chunk` a string containing the XML chunk\n    // `level` current indentation level\n    onData(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    }\n\n    // Called when the XML document is completed\n    onEnd() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    }\n\n    // Returns debug string\n    debugInfo(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    }\n\n    // Node aliases\n    ele() {\n      return this.element(...arguments);\n    }\n\n    nod(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    txt(value) {\n      return this.text(value);\n    }\n\n    dat(value) {\n      return this.cdata(value);\n    }\n\n    com(value) {\n      return this.comment(value);\n    }\n\n    ins(target, value) {\n      return this.instruction(target, value);\n    }\n\n    dec(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    }\n\n    dtd(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    }\n\n    e(name, attributes, text) {\n      return this.element(name, attributes, text);\n    }\n\n    n(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    t(value) {\n      return this.text(value);\n    }\n\n    d(value) {\n      return this.cdata(value);\n    }\n\n    c(value) {\n      return this.comment(value);\n    }\n\n    r(value) {\n      return this.raw(value);\n    }\n\n    i(target, value) {\n      return this.instruction(target, value);\n    }\n\n    // Attribute aliases\n    att() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    a() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    // DTD aliases\n    // att() and ele() are defined above\n    ent(name, value) {\n      return this.entity(name, value);\n    }\n\n    pent(name, value) {\n      return this.pEntity(name, value);\n    }\n\n    not(name, value) {\n      return this.notation(name, value);\n    }\n\n  };\n\n}).call(this);\n"]},"metadata":{},"sourceType":"module"}
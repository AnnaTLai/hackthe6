{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n      WriterState,\n      XMLStreamWriter,\n      XMLWriterBase,\n      hasProp = {}.hasOwnProperty;\n  NodeType = require('./NodeType');\n  XMLWriterBase = require('./XMLWriterBase');\n  WriterState = require('./WriterState'); // Prints XML nodes to a stream\n\n  module.exports = XMLStreamWriter = class XMLStreamWriter extends XMLWriterBase {\n    // Initializes a new instance of `XMLStreamWriter`\n    // `stream` output stream\n    // `options.pretty` pretty prints the result\n    // `options.indent` indentation string\n    // `options.newline` newline sequence\n    // `options.offset` a fixed number of indentations to add to every line\n    // `options.allowEmpty` do not self close empty element tags\n    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF\n    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements\n    constructor(stream, options) {\n      super(options);\n      this.stream = stream;\n    }\n\n    endline(node, options, level) {\n      if (node.isLastRootNode && options.state === WriterState.CloseTag) {\n        return '';\n      } else {\n        return super.endline(node, options, level);\n      }\n    }\n\n    document(doc, options) {\n      var child, i, j, k, len1, len2, ref, ref1, results;\n      ref = doc.children; // set a flag so that we don't insert a newline after the last root level node \n\n      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n        child = ref[i];\n        child.isLastRootNode = i === doc.children.length - 1;\n      }\n\n      options = this.filterOptions(options);\n      ref1 = doc.children;\n      results = [];\n\n      for (k = 0, len2 = ref1.length; k < len2; k++) {\n        child = ref1[k];\n        results.push(this.writeChildNode(child, options, 0));\n      }\n\n      return results;\n    }\n\n    cdata(node, options, level) {\n      return this.stream.write(super.cdata(node, options, level));\n    }\n\n    comment(node, options, level) {\n      return this.stream.write(super.comment(node, options, level));\n    }\n\n    declaration(node, options, level) {\n      return this.stream.write(super.declaration(node, options, level));\n    }\n\n    docType(node, options, level) {\n      var child, j, len1, ref;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      this.stream.write(this.indent(node, options, level));\n      this.stream.write('<!DOCTYPE ' + node.root().name); // external identifier\n\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      } // internal subset\n\n\n      if (node.children.length > 0) {\n        this.stream.write(' [');\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref = node.children;\n\n        for (j = 0, len1 = ref.length; j < len1; j++) {\n          child = ref[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n\n        options.state = WriterState.CloseTag;\n        this.stream.write(']');\n      } // close tag\n\n\n      options.state = WriterState.CloseTag;\n      this.stream.write(options.spaceBeforeSlash + '>');\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    }\n\n    element(node, options, level) {\n      var att, attLen, child, childNodeCount, firstChildNode, j, len, len1, name, prettySuppressed, r, ratt, ref, ref1, ref2, rline;\n      level || (level = 0); // open tag\n\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<' + node.name; // attributes\n\n      if (options.pretty && options.width > 0) {\n        len = r.length;\n        ref = node.attribs;\n\n        for (name in ref) {\n          if (!hasProp.call(ref, name)) continue;\n          att = ref[name];\n          ratt = this.attribute(att, options, level);\n          attLen = ratt.length;\n\n          if (len + attLen > options.width) {\n            rline = this.indent(node, options, level + 1) + ratt;\n            r += this.endline(node, options, level) + rline;\n            len = rline.length;\n          } else {\n            rline = ' ' + ratt;\n            r += rline;\n            len += rline.length;\n          }\n        }\n      } else {\n        ref1 = node.attribs;\n\n        for (name in ref1) {\n          if (!hasProp.call(ref1, name)) continue;\n          att = ref1[name];\n          r += this.attribute(att, options, level);\n        }\n      }\n\n      this.stream.write(r);\n      childNodeCount = node.children.length;\n      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n\n      if (childNodeCount === 0 || node.children.every(function (e) {\n        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n      })) {\n        // empty element\n        if (options.allowEmpty) {\n          this.stream.write('>');\n          options.state = WriterState.CloseTag;\n          this.stream.write('</' + node.name + '>');\n        } else {\n          options.state = WriterState.CloseTag;\n          this.stream.write(options.spaceBeforeSlash + '/>');\n        }\n      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {\n        // do not indent text-only nodes\n        this.stream.write('>');\n        options.state = WriterState.InsideTag;\n        options.suppressPrettyCount++;\n        prettySuppressed = true;\n        this.writeChildNode(firstChildNode, options, level + 1);\n        options.suppressPrettyCount--;\n        prettySuppressed = false;\n        options.state = WriterState.CloseTag;\n        this.stream.write('</' + node.name + '>');\n      } else {\n        this.stream.write('>' + this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref2 = node.children; // inner tags\n\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          child = ref2[j];\n          this.writeChildNode(child, options, level + 1);\n        } // close tag\n\n\n        options.state = WriterState.CloseTag;\n        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');\n      }\n\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    }\n\n    processingInstruction(node, options, level) {\n      return this.stream.write(super.processingInstruction(node, options, level));\n    }\n\n    raw(node, options, level) {\n      return this.stream.write(super.raw(node, options, level));\n    }\n\n    text(node, options, level) {\n      return this.stream.write(super.text(node, options, level));\n    }\n\n    dtdAttList(node, options, level) {\n      return this.stream.write(super.dtdAttList(node, options, level));\n    }\n\n    dtdElement(node, options, level) {\n      return this.stream.write(super.dtdElement(node, options, level));\n    }\n\n    dtdEntity(node, options, level) {\n      return this.stream.write(super.dtdEntity(node, options, level));\n    }\n\n    dtdNotation(node, options, level) {\n      return this.stream.write(super.dtdNotation(node, options, level));\n    }\n\n  };\n}).call(this);","map":{"version":3,"sources":["/Users/tony_niu/Visual Studio/Twilio/twilio-video-starter-kit/node_modules/xmlbuilder/lib/XMLStreamWriter.js"],"names":["NodeType","WriterState","XMLStreamWriter","XMLWriterBase","hasProp","hasOwnProperty","require","module","exports","constructor","stream","options","endline","node","level","isLastRootNode","state","CloseTag","document","doc","child","i","j","k","len1","len2","ref","ref1","results","children","length","filterOptions","push","writeChildNode","cdata","write","comment","declaration","docType","openNode","OpenTag","indent","root","name","pubID","sysID","InsideTag","spaceBeforeSlash","None","closeNode","element","att","attLen","childNodeCount","firstChildNode","len","prettySuppressed","r","ratt","ref2","rline","pretty","width","attribs","call","attribute","every","e","type","Text","Raw","value","allowEmpty","suppressPrettyCount","processingInstruction","raw","text","dtdAttList","dtdElement","dtdEntity","dtdNotation"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var NodeType, WriterState, XMLStreamWriter, XMLWriterBase,\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLWriterBase = require('./XMLWriterBase');\n\n  WriterState = require('./WriterState');\n\n  // Prints XML nodes to a stream\n  module.exports = XMLStreamWriter = class XMLStreamWriter extends XMLWriterBase {\n    // Initializes a new instance of `XMLStreamWriter`\n\n    // `stream` output stream\n    // `options.pretty` pretty prints the result\n    // `options.indent` indentation string\n    // `options.newline` newline sequence\n    // `options.offset` a fixed number of indentations to add to every line\n    // `options.allowEmpty` do not self close empty element tags\n    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF\n    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements\n    constructor(stream, options) {\n      super(options);\n      this.stream = stream;\n    }\n\n    endline(node, options, level) {\n      if (node.isLastRootNode && options.state === WriterState.CloseTag) {\n        return '';\n      } else {\n        return super.endline(node, options, level);\n      }\n    }\n\n    document(doc, options) {\n      var child, i, j, k, len1, len2, ref, ref1, results;\n      ref = doc.children;\n      // set a flag so that we don't insert a newline after the last root level node \n      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n        child = ref[i];\n        child.isLastRootNode = i === doc.children.length - 1;\n      }\n      options = this.filterOptions(options);\n      ref1 = doc.children;\n      results = [];\n      for (k = 0, len2 = ref1.length; k < len2; k++) {\n        child = ref1[k];\n        results.push(this.writeChildNode(child, options, 0));\n      }\n      return results;\n    }\n\n    cdata(node, options, level) {\n      return this.stream.write(super.cdata(node, options, level));\n    }\n\n    comment(node, options, level) {\n      return this.stream.write(super.comment(node, options, level));\n    }\n\n    declaration(node, options, level) {\n      return this.stream.write(super.declaration(node, options, level));\n    }\n\n    docType(node, options, level) {\n      var child, j, len1, ref;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      this.stream.write(this.indent(node, options, level));\n      this.stream.write('<!DOCTYPE ' + node.root().name);\n      // external identifier\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      }\n      // internal subset\n      if (node.children.length > 0) {\n        this.stream.write(' [');\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref = node.children;\n        for (j = 0, len1 = ref.length; j < len1; j++) {\n          child = ref[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        this.stream.write(']');\n      }\n      // close tag\n      options.state = WriterState.CloseTag;\n      this.stream.write(options.spaceBeforeSlash + '>');\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    }\n\n    element(node, options, level) {\n      var att, attLen, child, childNodeCount, firstChildNode, j, len, len1, name, prettySuppressed, r, ratt, ref, ref1, ref2, rline;\n      level || (level = 0);\n      // open tag\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<' + node.name;\n      // attributes\n      if (options.pretty && options.width > 0) {\n        len = r.length;\n        ref = node.attribs;\n        for (name in ref) {\n          if (!hasProp.call(ref, name)) continue;\n          att = ref[name];\n          ratt = this.attribute(att, options, level);\n          attLen = ratt.length;\n          if (len + attLen > options.width) {\n            rline = this.indent(node, options, level + 1) + ratt;\n            r += this.endline(node, options, level) + rline;\n            len = rline.length;\n          } else {\n            rline = ' ' + ratt;\n            r += rline;\n            len += rline.length;\n          }\n        }\n      } else {\n        ref1 = node.attribs;\n        for (name in ref1) {\n          if (!hasProp.call(ref1, name)) continue;\n          att = ref1[name];\n          r += this.attribute(att, options, level);\n        }\n      }\n      this.stream.write(r);\n      childNodeCount = node.children.length;\n      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n      if (childNodeCount === 0 || node.children.every(function(e) {\n        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n      })) {\n        // empty element\n        if (options.allowEmpty) {\n          this.stream.write('>');\n          options.state = WriterState.CloseTag;\n          this.stream.write('</' + node.name + '>');\n        } else {\n          options.state = WriterState.CloseTag;\n          this.stream.write(options.spaceBeforeSlash + '/>');\n        }\n      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {\n        // do not indent text-only nodes\n        this.stream.write('>');\n        options.state = WriterState.InsideTag;\n        options.suppressPrettyCount++;\n        prettySuppressed = true;\n        this.writeChildNode(firstChildNode, options, level + 1);\n        options.suppressPrettyCount--;\n        prettySuppressed = false;\n        options.state = WriterState.CloseTag;\n        this.stream.write('</' + node.name + '>');\n      } else {\n        this.stream.write('>' + this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref2 = node.children;\n        // inner tags\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          child = ref2[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n        // close tag\n        options.state = WriterState.CloseTag;\n        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');\n      }\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    }\n\n    processingInstruction(node, options, level) {\n      return this.stream.write(super.processingInstruction(node, options, level));\n    }\n\n    raw(node, options, level) {\n      return this.stream.write(super.raw(node, options, level));\n    }\n\n    text(node, options, level) {\n      return this.stream.write(super.text(node, options, level));\n    }\n\n    dtdAttList(node, options, level) {\n      return this.stream.write(super.dtdAttList(node, options, level));\n    }\n\n    dtdElement(node, options, level) {\n      return this.stream.write(super.dtdElement(node, options, level));\n    }\n\n    dtdEntity(node, options, level) {\n      return this.stream.write(super.dtdEntity(node, options, level));\n    }\n\n    dtdNotation(node, options, level) {\n      return this.stream.write(super.dtdNotation(node, options, level));\n    }\n\n  };\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}
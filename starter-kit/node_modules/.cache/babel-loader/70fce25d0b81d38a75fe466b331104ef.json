{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction;\n  ({\n    assign,\n    isFunction\n  } = require('./Utility'));\n  XMLDOMImplementation = require('./XMLDOMImplementation');\n  XMLDocument = require('./XMLDocument');\n  XMLDocumentCB = require('./XMLDocumentCB');\n  XMLStringWriter = require('./XMLStringWriter');\n  XMLStreamWriter = require('./XMLStreamWriter');\n  NodeType = require('./NodeType');\n  WriterState = require('./WriterState'); // Creates a new document and returns the root node for\n  // chain-building the document tree\n  // `name` name of the root element\n  // `xmldec.version` A version number string, e.g. 1.0\n  // `xmldec.encoding` Encoding declaration, e.g. UTF-8\n  // `xmldec.standalone` standalone document declaration: true or false\n  // `doctype.pubID` public identifier of the external subset\n  // `doctype.sysID` system identifier of the external subset\n  // `options.headless` whether XML declaration and doctype will be included:\n  //     true or false\n  // `options.keepNullNodes` whether nodes with null values will be kept\n  //     or ignored: true or false\n  // `options.keepNullAttributes` whether attributes with null values will be\n  //     kept or ignored: true or false\n  // `options.ignoreDecorators` whether decorator strings will be ignored when\n  //     converting JS objects: true or false\n  // `options.separateArrayItems` whether array items are created as separate\n  //     nodes when passed as an object value: true or false\n  // `options.noDoubleEncoding` whether existing html entities are encoded:\n  //     true or false\n  // `options.stringify` a set of functions to use for converting values to\n  //     strings\n  // `options.writer` the default XML writer to use for converting nodes to\n  //     string. If the default writer is not set, the built-in XMLStringWriter\n  //     will be used instead.\n\n  module.exports.create = function (name, xmldec, doctype, options) {\n    var doc, root;\n\n    if (name == null) {\n      throw new Error(\"Root element needs a name.\");\n    }\n\n    options = assign({}, xmldec, doctype, options); // create the document node\n\n    doc = new XMLDocument(options); // add the root node\n\n    root = doc.element(name); // prolog\n\n    if (!options.headless) {\n      doc.declaration(options);\n\n      if (options.pubID != null || options.sysID != null) {\n        doc.dtd(options);\n      }\n    }\n\n    return root;\n  }; // Creates a new document and returns the document node for\n  // chain-building the document tree\n  // `options.keepNullNodes` whether nodes with null values will be kept\n  //     or ignored: true or false\n  // `options.keepNullAttributes` whether attributes with null values will be\n  //     kept or ignored: true or false\n  // `options.ignoreDecorators` whether decorator strings will be ignored when\n  //     converting JS objects: true or false\n  // `options.separateArrayItems` whether array items are created as separate\n  //     nodes when passed as an object value: true or false\n  // `options.noDoubleEncoding` whether existing html entities are encoded:\n  //     true or false\n  // `options.stringify` a set of functions to use for converting values to\n  //     strings\n  // `options.writer` the default XML writer to use for converting nodes to\n  //     string. If the default writer is not set, the built-in XMLStringWriter\n  //     will be used instead.\n  // `onData` the function to be called when a new chunk of XML is output. The\n  //          string containing the XML chunk is passed to `onData` as its single\n  //          argument.\n  // `onEnd`  the function to be called when the XML document is completed with\n  //          `end`. `onEnd` does not receive any arguments.\n\n\n  module.exports.begin = function (options, onData, onEnd) {\n    if (isFunction(options)) {\n      [onData, onEnd] = [options, onData];\n      options = {};\n    }\n\n    if (onData) {\n      return new XMLDocumentCB(options, onData, onEnd);\n    } else {\n      return new XMLDocument(options);\n    }\n  };\n\n  module.exports.stringWriter = function (options) {\n    return new XMLStringWriter(options);\n  };\n\n  module.exports.streamWriter = function (stream, options) {\n    return new XMLStreamWriter(stream, options);\n  };\n\n  module.exports.implementation = new XMLDOMImplementation();\n  module.exports.nodeType = NodeType;\n  module.exports.writerState = WriterState;\n}).call(this);","map":{"version":3,"sources":["/Users/tony_niu/Visual Studio/Twilio/twilio-video-starter-kit/node_modules/xmlbuilder/lib/index.js"],"names":["NodeType","WriterState","XMLDOMImplementation","XMLDocument","XMLDocumentCB","XMLStreamWriter","XMLStringWriter","assign","isFunction","require","module","exports","create","name","xmldec","doctype","options","doc","root","Error","element","headless","declaration","pubID","sysID","dtd","begin","onData","onEnd","stringWriter","streamWriter","stream","implementation","nodeType","writerState","call"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction;\n\n  ({assign, isFunction} = require('./Utility'));\n\n  XMLDOMImplementation = require('./XMLDOMImplementation');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLDocumentCB = require('./XMLDocumentCB');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  XMLStreamWriter = require('./XMLStreamWriter');\n\n  NodeType = require('./NodeType');\n\n  WriterState = require('./WriterState');\n\n  // Creates a new document and returns the root node for\n  // chain-building the document tree\n\n  // `name` name of the root element\n\n  // `xmldec.version` A version number string, e.g. 1.0\n  // `xmldec.encoding` Encoding declaration, e.g. UTF-8\n  // `xmldec.standalone` standalone document declaration: true or false\n\n  // `doctype.pubID` public identifier of the external subset\n  // `doctype.sysID` system identifier of the external subset\n\n  // `options.headless` whether XML declaration and doctype will be included:\n  //     true or false\n  // `options.keepNullNodes` whether nodes with null values will be kept\n  //     or ignored: true or false\n  // `options.keepNullAttributes` whether attributes with null values will be\n  //     kept or ignored: true or false\n  // `options.ignoreDecorators` whether decorator strings will be ignored when\n  //     converting JS objects: true or false\n  // `options.separateArrayItems` whether array items are created as separate\n  //     nodes when passed as an object value: true or false\n  // `options.noDoubleEncoding` whether existing html entities are encoded:\n  //     true or false\n  // `options.stringify` a set of functions to use for converting values to\n  //     strings\n  // `options.writer` the default XML writer to use for converting nodes to\n  //     string. If the default writer is not set, the built-in XMLStringWriter\n  //     will be used instead.\n  module.exports.create = function(name, xmldec, doctype, options) {\n    var doc, root;\n    if (name == null) {\n      throw new Error(\"Root element needs a name.\");\n    }\n    options = assign({}, xmldec, doctype, options);\n    // create the document node\n    doc = new XMLDocument(options);\n    // add the root node\n    root = doc.element(name);\n    // prolog\n    if (!options.headless) {\n      doc.declaration(options);\n      if ((options.pubID != null) || (options.sysID != null)) {\n        doc.dtd(options);\n      }\n    }\n    return root;\n  };\n\n  // Creates a new document and returns the document node for\n  // chain-building the document tree\n\n  // `options.keepNullNodes` whether nodes with null values will be kept\n  //     or ignored: true or false\n  // `options.keepNullAttributes` whether attributes with null values will be\n  //     kept or ignored: true or false\n  // `options.ignoreDecorators` whether decorator strings will be ignored when\n  //     converting JS objects: true or false\n  // `options.separateArrayItems` whether array items are created as separate\n  //     nodes when passed as an object value: true or false\n  // `options.noDoubleEncoding` whether existing html entities are encoded:\n  //     true or false\n  // `options.stringify` a set of functions to use for converting values to\n  //     strings\n  // `options.writer` the default XML writer to use for converting nodes to\n  //     string. If the default writer is not set, the built-in XMLStringWriter\n  //     will be used instead.\n\n  // `onData` the function to be called when a new chunk of XML is output. The\n  //          string containing the XML chunk is passed to `onData` as its single\n  //          argument.\n  // `onEnd`  the function to be called when the XML document is completed with\n  //          `end`. `onEnd` does not receive any arguments.\n  module.exports.begin = function(options, onData, onEnd) {\n    if (isFunction(options)) {\n      [onData, onEnd] = [options, onData];\n      options = {};\n    }\n    if (onData) {\n      return new XMLDocumentCB(options, onData, onEnd);\n    } else {\n      return new XMLDocument(options);\n    }\n  };\n\n  module.exports.stringWriter = function(options) {\n    return new XMLStringWriter(options);\n  };\n\n  module.exports.streamWriter = function(stream, options) {\n    return new XMLStreamWriter(stream, options);\n  };\n\n  module.exports.implementation = new XMLDOMImplementation();\n\n  module.exports.nodeType = NodeType;\n\n  module.exports.writerState = WriterState;\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar detectSilence = require('./detectsilence');\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\n\n\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  var retry = 0; // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n\n  var AudioContextFactory = require('./audiocontext');\n\n  var holder = {};\n  var audioContext = AudioContextFactory.getOrCreate(holder);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n\n  function doWorkaround() {\n    return getUserMedia(constraints).then(function (stream) {\n      var isSilentPromise = constraints.audio ? detectSilence(audioContext, stream, timeout).catch(function (err) {\n        log.warn('Encountered an error while detecting silence', err);\n        return true;\n      }) : Promise.resolve(false);\n      return isSilentPromise.then(function (isSilent) {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n\n        log.warn('Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #' + ++retry + '.');\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n\n  return doWorkaround().then(function (stream) {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, function (error) {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\n\nmodule.exports = workaround;","map":{"version":3,"sources":["/Users/tony_niu/Visual Studio/Twilio/twilio-video-starter-kit/node_modules/twilio-video/es5/webaudio/workaround180748.js"],"names":["detectSilence","require","workaround","log","getUserMedia","constraints","n","timeout","retry","AudioContextFactory","holder","audioContext","getOrCreate","doWorkaround","then","stream","isSilentPromise","audio","catch","err","warn","Promise","resolve","isSilent","info","getTracks","forEach","track","stop","release","error","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBC,GAApB,EAAyBC,YAAzB,EAAuCC,WAAvC,EAAoDC,CAApD,EAAuDC,OAAvD,EAAgE;AAC9DD,EAAAA,CAAC,GAAG,OAAOA,CAAP,KAAa,QAAb,GAAwBA,CAAxB,GAA4B,CAAhC;AACA,MAAIE,KAAK,GAAG,CAAZ,CAF8D,CAI9D;AACA;;AACA,MAAIC,mBAAmB,GAAGR,OAAO,CAAC,gBAAD,CAAjC;;AACA,MAAIS,MAAM,GAAG,EAAb;AACA,MAAIC,YAAY,GAAGF,mBAAmB,CAACG,WAApB,CAAgCF,MAAhC,CAAnB;AAEA;AACF;AACA;AACA;;AACE,WAASG,YAAT,GAAwB;AACtB,WAAOT,YAAY,CAACC,WAAD,CAAZ,CAA0BS,IAA1B,CAA+B,UAAUC,MAAV,EAAkB;AACtD,UAAIC,eAAe,GAAGX,WAAW,CAACY,KAAZ,GAAoBjB,aAAa,CAACW,YAAD,EAAeI,MAAf,EAAuBR,OAAvB,CAAb,CAA6CW,KAA7C,CAAmD,UAAUC,GAAV,EAAe;AAC1GhB,QAAAA,GAAG,CAACiB,IAAJ,CAAS,8CAAT,EAAyDD,GAAzD;AACA,eAAO,IAAP;AACD,OAHyC,CAApB,GAGjBE,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAHL;AAIA,aAAON,eAAe,CAACF,IAAhB,CAAqB,UAAUS,QAAV,EAAoB;AAC9C,YAAI,CAACA,QAAL,EAAe;AACbpB,UAAAA,GAAG,CAACqB,IAAJ,CAAS,wDAAT;AACA,iBAAOT,MAAP;AACD,SAHD,MAGO,IAAIT,CAAC,IAAI,CAAT,EAAY;AACjBH,UAAAA,GAAG,CAACiB,IAAJ,CAAS;AACnB,sEADU;AAEA,iBAAOL,MAAP;AACD;;AACDZ,QAAAA,GAAG,CAACiB,IAAJ,CAAS,wHAAwH,EAAEZ,KAA1H,GAAkI,GAA3I;AACAO,QAAAA,MAAM,CAACU,SAAP,GAAmBC,OAAnB,CAA2B,UAAUC,KAAV,EAAiB;AAC1C,iBAAOA,KAAK,CAACC,IAAN,EAAP;AACD,SAFD;AAGAtB,QAAAA,CAAC;AACD,eAAOO,YAAY,EAAnB;AACD,OAfM,CAAP;AAgBD,KArBM,CAAP;AAsBD;;AAED,SAAOA,YAAY,GAAGC,IAAf,CAAoB,UAAUC,MAAV,EAAkB;AAC3CN,IAAAA,mBAAmB,CAACoB,OAApB,CAA4BnB,MAA5B;AACA,WAAOK,MAAP;AACD,GAHM,EAGJ,UAAUe,KAAV,EAAiB;AAClBrB,IAAAA,mBAAmB,CAACoB,OAApB,CAA4BnB,MAA5B;AACA,UAAMoB,KAAN;AACD,GANM,CAAP;AAOD;;AAEDC,MAAM,CAACC,OAAP,GAAiB9B,UAAjB","sourcesContent":["'use strict';\n\nvar detectSilence = require('./detectsilence');\n\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  var retry = 0;\n\n  // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n  var AudioContextFactory = require('./audiocontext');\n  var holder = {};\n  var audioContext = AudioContextFactory.getOrCreate(holder);\n\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n  function doWorkaround() {\n    return getUserMedia(constraints).then(function (stream) {\n      var isSilentPromise = constraints.audio ? detectSilence(audioContext, stream, timeout).catch(function (err) {\n        log.warn('Encountered an error while detecting silence', err);\n        return true;\n      }) : Promise.resolve(false);\n      return isSilentPromise.then(function (isSilent) {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n        log.warn('Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #' + ++retry + '.');\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n\n  return doWorkaround().then(function (stream) {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, function (error) {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\n\nmodule.exports = workaround;"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\n\nvar _ = require('lodash');\n\nvar scmp = require('scmp');\n\nvar urllib = require('url');\n\nvar Url = require('url-parse');\n/**\n * Utility function to construct the URL string, since Node.js url library won't include standard port numbers\n *\n * @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n * @returns {string} - URL with standard port number included\n */\n\n\nfunction buildUrlWithStandardPort(parsedUrl) {\n  let url = '';\n  const port = parsedUrl.protocol === 'https:' ? ':443' : ':80';\n  url += parsedUrl.protocol ? parsedUrl.protocol + '//' : '';\n  url += parsedUrl.username;\n  url += parsedUrl.password ? ':' + parsedUrl.password : '';\n  url += parsedUrl.username || parsedUrl.password ? '@' : '';\n  url += parsedUrl.host ? parsedUrl.host + port : '';\n  url += parsedUrl.pathname + parsedUrl.query + parsedUrl.hash;\n  return url;\n}\n/**\n Utility function to add a port number to a URL\n\n @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n @returns {string} - URL with port\n */\n\n\nfunction addPort(parsedUrl) {\n  if (!parsedUrl.port) {\n    return buildUrlWithStandardPort(parsedUrl);\n  }\n\n  return parsedUrl.toString();\n}\n/**\n Utility function to remove a port number from a URL\n\n @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n @returns {string} - URL without port\n */\n\n\nfunction removePort(parsedUrl) {\n  parsedUrl.set('port', '');\n  return parsedUrl.toString();\n}\n/**\n Utility function to get the expected signature for a given request\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {object} params - the parameters sent with this request\n @returns {string} - signature\n */\n\n\nfunction getExpectedTwilioSignature(authToken, url, params) {\n  if (url.indexOf('bodySHA256') !== -1 && params === null) {\n    params = {};\n  }\n\n  var data = Object.keys(params).sort().reduce((acc, key) => acc + key + params[key], url);\n  return crypto.createHmac('sha1', authToken).update(Buffer.from(data, 'utf-8')).digest('base64');\n}\n/**\n Utility function to get the expected body hash for a given request's body\n\n @param {string} body - The plain-text body of the request\n */\n\n\nfunction getExpectedBodyHash(body) {\n  return crypto.createHash('sha256').update(Buffer.from(body, 'utf-8')).digest('hex');\n}\n/**\n Utility function to validate an incoming request is indeed from Twilio\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} twilioHeader - The value of the X-Twilio-Signature header from the request\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {object} params - the parameters sent with this request\n @returns {boolean} - valid\n */\n\n\nfunction validateRequest(authToken, twilioHeader, url, params) {\n  twilioHeader = twilioHeader || '';\n  const urlObject = new Url(url);\n  const urlWithPort = addPort(urlObject);\n  const urlWithoutPort = removePort(urlObject);\n  /*\n   *  Check signature of the url with and without the port number\n   *  since signature generation on the back end is inconsistent\n   */\n\n  const signatureWithPort = getExpectedTwilioSignature(authToken, urlWithPort, params);\n  const signatureWithoutPort = getExpectedTwilioSignature(authToken, urlWithoutPort, params);\n  const validSignatureWithPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithPort));\n  const validSignatureWithoutPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithoutPort));\n  return validSignatureWithoutPort || validSignatureWithPort;\n}\n\nfunction validateBody(body, bodyHash) {\n  var expectedHash = getExpectedBodyHash(body);\n  return scmp(Buffer.from(bodyHash), Buffer.from(expectedHash));\n}\n/**\n Utility function to validate an incoming request is indeed from Twilio. This also validates\n the request body against the bodySHA256 post parameter.\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} twilioHeader - The value of the X-Twilio-Signature header from the request\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {string} body - The body of the request\n @returns {boolean} - valid\n */\n\n\nfunction validateRequestWithBody(authToken, twilioHeader, url, body) {\n  const urlObject = new Url(url, true);\n  return validateRequest(authToken, twilioHeader, url, {}) && validateBody(body, urlObject.query.bodySHA256);\n}\n/**\n Utility function to validate an incoming request is indeed from Twilio (for use with express).\n adapted from https://github.com/crabasa/twiliosig\n\n @param {object} request - An expressjs request object (http://expressjs.com/api.html#req.params)\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {object} opts - options for request validation:\n    - url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n    - host: manually specify the host name used by Twilio in a number's webhook config\n    - protocol: manually specify the protocol used by Twilio in a number's webhook config\n */\n\n\nfunction validateExpressRequest(request, authToken, opts) {\n  var options = opts || {};\n  var webhookUrl;\n\n  if (options.url) {\n    // Let the user specify the full URL\n    webhookUrl = options.url;\n  } else {\n    // Use configured host/protocol, or infer based on request\n    var protocol = options.protocol || request.protocol;\n    var host = options.host || request.headers.host;\n    webhookUrl = urllib.format({\n      protocol: protocol,\n      host: host,\n      pathname: request.originalUrl\n    });\n\n    if (request.originalUrl.search(/\\?/) >= 0) {\n      webhookUrl = webhookUrl.replace(/%3F/g, '?');\n    }\n  }\n\n  if (webhookUrl.indexOf('bodySHA256') > 0) {\n    return validateRequestWithBody(authToken, request.header('X-Twilio-Signature'), webhookUrl, request.rawBody || '{}');\n  } else {\n    return validateRequest(authToken, request.header('X-Twilio-Signature'), webhookUrl, request.body || {});\n  }\n}\n/**\nExpress middleware to accompany a Twilio webhook. Provides Twilio\nrequest validation, and makes the response a little more friendly for our\nTwiML generator.  Request validation requires the express.urlencoded middleware\nto have been applied (e.g. app.use(express.urlencoded()); in your app config).\n\nOptions:\n- validate: {Boolean} whether or not the middleware should validate the request\n    came from Twilio.  Default true. If the request does not originate from\n    Twilio, we will return a text body and a 403.  If there is no configured\n    auth token and validate=true, this is an error condition, so we will return\n    a 500.\n- host: manually specify the host name used by Twilio in a number's webhook config\n- protocol: manually specify the protocol used by Twilio in a number's webhook config\n- url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n\nReturns a middleware function.\n\nExamples:\nvar webhookMiddleware = twilio.webhook();\nvar webhookMiddleware = twilio.webhook('asdha9dhjasd'); //init with auth token\nvar webhookMiddleware = twilio.webhook({\n    validate:false // don't attempt request validation\n});\nvar webhookMiddleware = twilio.webhook({\n    host: 'hook.twilio.com',\n    protocol: 'https'\n});\n */\n\n\nfunction webhook() {\n  var opts = {\n    validate: true\n  }; // Process arguments\n\n  var tokenString;\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    var arg = arguments[i];\n\n    if (typeof arg === 'string') {\n      tokenString = arg;\n    } else {\n      opts = _.extend(opts, arg);\n    }\n  } // set auth token from input or environment variable\n\n\n  opts.authToken = tokenString ? tokenString : process.env.TWILIO_AUTH_TOKEN; // Create middleware function\n\n  return function hook(request, response, next) {\n    // Do validation if requested\n    if (opts.validate) {\n      // Check if the 'X-Twilio-Signature' header exists or not\n      if (!request.header('X-Twilio-Signature')) {\n        return response.type('text/plain').status(400).send('No signature header error - X-Twilio-Signature header does not exist, maybe this request is not coming from Twilio.');\n      } // Check for a valid auth token\n\n\n      if (!opts.authToken) {\n        console.error('[Twilio]: Error - Twilio auth token is required for webhook request validation.');\n        response.type('text/plain').status(500).send('Webhook Error - we attempted to validate this request without first configuring our auth token.');\n      } else {\n        // Check that the request originated from Twilio\n        var valid = validateExpressRequest(request, opts.authToken, {\n          url: opts.url,\n          host: opts.host,\n          protocol: opts.protocol\n        });\n\n        if (valid) {\n          next();\n        } else {\n          return response.type('text/plain').status(403).send('Twilio Request Validation Failed.');\n        }\n      }\n    } else {\n      next();\n    }\n  };\n}\n\nmodule.exports = {\n  getExpectedTwilioSignature,\n  getExpectedBodyHash,\n  validateRequest,\n  validateRequestWithBody,\n  validateExpressRequest,\n  validateBody,\n  webhook\n};","map":{"version":3,"sources":["/Users/tony_niu/Visual Studio/Twilio/twilio-video-starter-kit/node_modules/twilio/lib/webhooks/webhooks.js"],"names":["crypto","require","_","scmp","urllib","Url","buildUrlWithStandardPort","parsedUrl","url","port","protocol","username","password","host","pathname","query","hash","addPort","toString","removePort","set","getExpectedTwilioSignature","authToken","params","indexOf","data","Object","keys","sort","reduce","acc","key","createHmac","update","Buffer","from","digest","getExpectedBodyHash","body","createHash","validateRequest","twilioHeader","urlObject","urlWithPort","urlWithoutPort","signatureWithPort","signatureWithoutPort","validSignatureWithPort","validSignatureWithoutPort","validateBody","bodyHash","expectedHash","validateRequestWithBody","bodySHA256","validateExpressRequest","request","opts","options","webhookUrl","headers","format","originalUrl","search","replace","header","rawBody","webhook","validate","tokenString","i","l","arguments","length","arg","extend","process","env","TWILIO_AUTH_TOKEN","hook","response","next","type","status","send","console","error","valid","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar crypto = require('crypto');\nvar _ = require('lodash');\nvar scmp = require('scmp');\nvar urllib = require('url');\nvar Url = require('url-parse');\n\n/**\n * Utility function to construct the URL string, since Node.js url library won't include standard port numbers\n *\n * @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n * @returns {string} - URL with standard port number included\n */\nfunction buildUrlWithStandardPort(parsedUrl) {\n  let url = '';\n  const port = parsedUrl.protocol === 'https:' ? ':443' : ':80';\n\n  url += parsedUrl.protocol ? parsedUrl.protocol + '//' : '';\n  url += parsedUrl.username;\n  url += parsedUrl.password ? ':' + parsedUrl.password : '';\n  url += (parsedUrl.username || parsedUrl.password) ? '@' : '';\n  url += parsedUrl.host ? parsedUrl.host + port : '';\n  url += parsedUrl.pathname + parsedUrl.query + parsedUrl.hash;\n\n  return url;\n}\n\n/**\n Utility function to add a port number to a URL\n\n @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n @returns {string} - URL with port\n */\nfunction addPort(parsedUrl) {\n  if (!parsedUrl.port) {\n    return buildUrlWithStandardPort(parsedUrl);\n  }\n  return parsedUrl.toString();\n}\n\n/**\n Utility function to remove a port number from a URL\n\n @param {Url} parsedUrl - The parsed url object that Twilio requested on your server\n @returns {string} - URL without port\n */\nfunction removePort(parsedUrl) {\n  parsedUrl.set('port', '');\n  return parsedUrl.toString();\n}\n\n/**\n Utility function to get the expected signature for a given request\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {object} params - the parameters sent with this request\n @returns {string} - signature\n */\nfunction getExpectedTwilioSignature(authToken, url, params) {\n  if (url.indexOf('bodySHA256') !== -1 && params === null) {\n    params = {};\n  }\n\n  var data = Object.keys(params)\n    .sort()\n    .reduce((acc, key) => acc + key + params[key], url);\n\n  return crypto\n    .createHmac('sha1', authToken)\n    .update(Buffer.from(data, 'utf-8'))\n    .digest('base64');\n}\n\n/**\n Utility function to get the expected body hash for a given request's body\n\n @param {string} body - The plain-text body of the request\n */\nfunction getExpectedBodyHash(body) {\n  return crypto\n    .createHash('sha256')\n    .update(Buffer.from(body, 'utf-8'))\n    .digest('hex');\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} twilioHeader - The value of the X-Twilio-Signature header from the request\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {object} params - the parameters sent with this request\n @returns {boolean} - valid\n */\nfunction validateRequest(authToken, twilioHeader, url, params) {\n  twilioHeader = twilioHeader || '';\n  const urlObject = new Url(url);\n  const urlWithPort = addPort(urlObject);\n  const urlWithoutPort = removePort(urlObject);\n\n  /*\n   *  Check signature of the url with and without the port number\n   *  since signature generation on the back end is inconsistent\n   */\n  const signatureWithPort = getExpectedTwilioSignature(authToken, urlWithPort, params);\n  const signatureWithoutPort = getExpectedTwilioSignature(authToken, urlWithoutPort, params);\n  const validSignatureWithPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithPort));\n  const validSignatureWithoutPort = scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithoutPort));\n\n  return validSignatureWithoutPort || validSignatureWithPort;\n}\n\nfunction validateBody(body, bodyHash) {\n  var expectedHash = getExpectedBodyHash(body);\n  return scmp(Buffer.from(bodyHash), Buffer.from(expectedHash));\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio. This also validates\n the request body against the bodySHA256 post parameter.\n\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {string} twilioHeader - The value of the X-Twilio-Signature header from the request\n @param {string} url - The full URL (with query string) you configured to handle this request\n @param {string} body - The body of the request\n @returns {boolean} - valid\n */\nfunction validateRequestWithBody(authToken, twilioHeader, url, body) {\n  const urlObject = new Url(url, true);\n  return validateRequest(authToken, twilioHeader, url, {}) &&\n    validateBody(body, urlObject.query.bodySHA256);\n}\n\n/**\n Utility function to validate an incoming request is indeed from Twilio (for use with express).\n adapted from https://github.com/crabasa/twiliosig\n\n @param {object} request - An expressjs request object (http://expressjs.com/api.html#req.params)\n @param {string} authToken - The auth token, as seen in the Twilio portal\n @param {object} opts - options for request validation:\n    - url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n    - host: manually specify the host name used by Twilio in a number's webhook config\n    - protocol: manually specify the protocol used by Twilio in a number's webhook config\n */\nfunction validateExpressRequest(request, authToken, opts) {\n  var options = opts || {};\n  var webhookUrl;\n\n  if (options.url) {\n    // Let the user specify the full URL\n    webhookUrl = options.url;\n  } else {\n    // Use configured host/protocol, or infer based on request\n    var protocol = options.protocol || request.protocol;\n    var host = options.host || request.headers.host;\n\n    webhookUrl = urllib.format({\n      protocol: protocol,\n      host: host,\n      pathname: request.originalUrl,\n    });\n    if (request.originalUrl.search(/\\?/) >= 0) {\n      webhookUrl = webhookUrl.replace(/%3F/g, '?');\n    }\n\n  }\n\n  if (webhookUrl.indexOf('bodySHA256') > 0) {\n    return validateRequestWithBody(\n      authToken,\n      request.header('X-Twilio-Signature'),\n      webhookUrl,\n      request.rawBody || '{}'\n    );\n  } else {\n    return validateRequest(\n      authToken,\n      request.header('X-Twilio-Signature'),\n      webhookUrl,\n      request.body || {}\n    );\n  }\n}\n\n/**\nExpress middleware to accompany a Twilio webhook. Provides Twilio\nrequest validation, and makes the response a little more friendly for our\nTwiML generator.  Request validation requires the express.urlencoded middleware\nto have been applied (e.g. app.use(express.urlencoded()); in your app config).\n\nOptions:\n- validate: {Boolean} whether or not the middleware should validate the request\n    came from Twilio.  Default true. If the request does not originate from\n    Twilio, we will return a text body and a 403.  If there is no configured\n    auth token and validate=true, this is an error condition, so we will return\n    a 500.\n- host: manually specify the host name used by Twilio in a number's webhook config\n- protocol: manually specify the protocol used by Twilio in a number's webhook config\n- url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n\nReturns a middleware function.\n\nExamples:\nvar webhookMiddleware = twilio.webhook();\nvar webhookMiddleware = twilio.webhook('asdha9dhjasd'); //init with auth token\nvar webhookMiddleware = twilio.webhook({\n    validate:false // don't attempt request validation\n});\nvar webhookMiddleware = twilio.webhook({\n    host: 'hook.twilio.com',\n    protocol: 'https'\n});\n */\nfunction webhook() {\n  var opts = {\n    validate: true,\n  };\n\n  // Process arguments\n  var tokenString;\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    var arg = arguments[i];\n    if (typeof arg === 'string') {\n      tokenString = arg;\n    } else {\n      opts = _.extend(opts, arg);\n    }\n  }\n\n  // set auth token from input or environment variable\n  opts.authToken = tokenString ? tokenString : process.env.TWILIO_AUTH_TOKEN;\n\n  // Create middleware function\n  return function hook(request, response, next) {\n    // Do validation if requested\n    if (opts.validate) {\n      // Check if the 'X-Twilio-Signature' header exists or not\n      if (!request.header('X-Twilio-Signature')) {\n        return response.type('text/plain')\n          .status(400)\n          .send('No signature header error - X-Twilio-Signature header does not exist, maybe this request is not coming from Twilio.');\n      }\n      // Check for a valid auth token\n      if (!opts.authToken) {\n        console.error('[Twilio]: Error - Twilio auth token is required for webhook request validation.');\n        response.type('text/plain')\n          .status(500)\n          .send('Webhook Error - we attempted to validate this request without first configuring our auth token.');\n      } else {\n        // Check that the request originated from Twilio\n        var valid = validateExpressRequest(request, opts.authToken, {\n          url: opts.url,\n          host: opts.host,\n          protocol: opts.protocol,\n        });\n\n        if (valid) {\n          next();\n        } else {\n          return response\n            .type('text/plain')\n            .status(403)\n            .send('Twilio Request Validation Failed.');\n        }\n      }\n    } else {\n      next();\n    }\n  };\n}\n\nmodule.exports = {\n  getExpectedTwilioSignature,\n  getExpectedBodyHash,\n  validateRequest,\n  validateRequestWithBody,\n  validateExpressRequest,\n  validateBody,\n  webhook,\n};\n"]},"metadata":{},"sourceType":"script"}
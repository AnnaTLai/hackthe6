{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var DocumentPosition,\n      NodeType,\n      XMLCData,\n      XMLComment,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDummy,\n      XMLElement,\n      XMLNamedNodeMap,\n      XMLNode,\n      XMLNodeList,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLText,\n      getValue,\n      isEmpty,\n      isFunction,\n      isObject,\n      hasProp = {}.hasOwnProperty,\n      splice = [].splice;\n  ({\n    isObject,\n    isFunction,\n    isEmpty,\n    getValue\n  } = require('./Utility'));\n  XMLElement = null;\n  XMLCData = null;\n  XMLComment = null;\n  XMLDeclaration = null;\n  XMLDocType = null;\n  XMLRaw = null;\n  XMLText = null;\n  XMLProcessingInstruction = null;\n  XMLDummy = null;\n  NodeType = null;\n  XMLNodeList = null;\n  XMLNamedNodeMap = null;\n  DocumentPosition = null; // Represents a generic XMl element\n\n  module.exports = XMLNode = function () {\n    class XMLNode {\n      // Initializes a new instance of `XMLNode`\n      // `parent` the parent node\n      constructor(parent1) {\n        this.parent = parent1;\n\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n\n        this.value = null;\n        this.children = [];\n        this.baseURI = null; // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      } // Sets the parent node of this node and its children recursively\n      // `parent` the parent node\n\n\n      setParent(parent) {\n        var child, j, len, ref1, results;\n        this.parent = parent;\n\n        if (parent) {\n          this.options = parent.options;\n          this.stringify = parent.stringify;\n        }\n\n        ref1 = this.children;\n        results = [];\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          results.push(child.setParent(this));\n        }\n\n        return results;\n      } // Creates a child element node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      element(name, attributes, text) {\n        var childNode, item, j, k, key, lastChild, len, len1, val;\n        lastChild = null;\n\n        if (attributes === null && text == null) {\n          [attributes, text] = [{}, null];\n        }\n\n        if (attributes == null) {\n          attributes = {};\n        }\n\n        attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n\n        if (name != null) {\n          name = getValue(name);\n        } // expand if array\n\n\n        if (Array.isArray(name)) {\n          for (j = 0, len = name.length; j < len; j++) {\n            item = name[j];\n            lastChild = this.element(item);\n          } // evaluate if function\n\n        } else if (isFunction(name)) {\n          lastChild = this.element(name.apply()); // expand if object\n        } else if (isObject(name)) {\n          for (key in name) {\n            if (!hasProp.call(name, key)) continue;\n            val = name[key];\n\n            if (isFunction(val)) {\n              // evaluate if function\n              val = val.apply();\n            } // assign attributes\n\n\n            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val); // skip empty arrays\n            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n              lastChild = this.dummy(); // empty objects produce one node\n            } else if (isObject(val) && isEmpty(val)) {\n              lastChild = this.element(key); // skip null and undefined nodes\n            } else if (!this.options.keepNullNodes && val == null) {\n              lastChild = this.dummy(); // expand list by creating child nodes\n            } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n              for (k = 0, len1 = val.length; k < len1; k++) {\n                item = val[k];\n                childNode = {};\n                childNode[key] = item;\n                lastChild = this.element(childNode);\n              } // expand child nodes under parent\n\n            } else if (isObject(val)) {\n              // if the key is #text expand child nodes under this node to support mixed content\n              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                lastChild = this.element(val);\n              } else {\n                lastChild = this.element(key);\n                lastChild.element(val);\n              }\n            } else {\n              // text node\n              lastChild = this.element(key, val);\n            }\n          } // skip null nodes\n\n        } else if (!this.options.keepNullNodes && text === null) {\n          lastChild = this.dummy();\n        } else {\n          // text node\n          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n            lastChild = this.text(text); // cdata node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n            lastChild = this.cdata(text); // comment node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n            lastChild = this.comment(text); // raw text node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n            lastChild = this.raw(text); // processing instruction\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n          } else {\n            // element node\n            lastChild = this.node(name, attributes, text);\n          }\n        }\n\n        if (lastChild == null) {\n          throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n        }\n\n        return lastChild;\n      } // Creates a child element node before the current node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      insertBefore(name, attributes, text) {\n        var child, i, newChild, refChild, removed; // DOM level 1\n        // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n\n        if (name != null ? name.type : void 0) {\n          newChild = name;\n          refChild = attributes;\n          newChild.setParent(this);\n\n          if (refChild) {\n            // temporarily remove children starting *with* refChild\n            i = children.indexOf(refChild);\n            removed = children.splice(i); // add the new child\n\n            children.push(newChild); // add back removed children after new child\n\n            Array.prototype.push.apply(children, removed);\n          } else {\n            children.push(newChild);\n          }\n\n          return newChild;\n        } else {\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          } // temporarily remove children starting *with* this\n\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i); // add the new child\n\n          child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        }\n      } // Creates a child element node after the current node\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      insertAfter(name, attributes, text) {\n        var child, i, removed;\n\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        } // temporarily remove children starting *after* this\n\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      } // Deletes a child element node\n\n\n      remove() {\n        var i, ref1;\n\n        if (this.isRoot) {\n          throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n        }\n\n        i = this.parent.children.indexOf(this);\n        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n        return this.parent;\n      } // Creates a node\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n\n      node(name, attributes, text) {\n        var child;\n\n        if (name != null) {\n          name = getValue(name);\n        }\n\n        attributes || (attributes = {});\n        attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n\n        child = new XMLElement(this, name, attributes);\n\n        if (text != null) {\n          child.text(text);\n        }\n\n        this.children.push(child);\n        return child;\n      } // Creates a text node\n      // `value` element text\n\n\n      text(value) {\n        var child;\n\n        if (isObject(value)) {\n          this.element(value);\n        }\n\n        child = new XMLText(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a CDATA node\n      // `value` element text without CDATA delimiters\n\n\n      cdata(value) {\n        var child;\n        child = new XMLCData(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a comment node\n      // `value` comment text\n\n\n      comment(value) {\n        var child;\n        child = new XMLComment(this, value);\n        this.children.push(child);\n        return this;\n      } // Creates a comment node before the current node\n      // `value` comment text\n\n\n      commentBefore(value) {\n        var child, i, removed; // temporarily remove children starting *with* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i); // add the new child\n\n        child = this.parent.comment(value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates a comment node after the current node\n      // `value` comment text\n\n\n      commentAfter(value) {\n        var child, i, removed; // temporarily remove children starting *after* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.comment(value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Adds unescaped raw text\n      // `value` text\n\n\n      raw(value) {\n        var child;\n        child = new XMLRaw(this, value);\n        this.children.push(child);\n        return this;\n      } // Adds a dummy node\n\n\n      dummy() {\n        var child;\n        child = new XMLDummy(this); // Normally when a new node is created it is added to the child node collection.\n        // However, dummy nodes are never added to the XML tree. They are created while\n        // converting JS objects to XML nodes in order not to break the recursive function\n        // chain. They can be thought of as invisible nodes. They can be traversed through\n        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n        // @children.push child\n\n        return child;\n      } // Adds a processing instruction\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instruction(target, value) {\n        var insTarget, insValue, instruction, j, len;\n\n        if (target != null) {\n          target = getValue(target);\n        }\n\n        if (value != null) {\n          value = getValue(value);\n        }\n\n        if (Array.isArray(target)) {\n          // expand if array\n          for (j = 0, len = target.length; j < len; j++) {\n            insTarget = target[j];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) {\n          // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n\n          instruction = new XMLProcessingInstruction(this, target, value);\n          this.children.push(instruction);\n        }\n\n        return this;\n      } // Creates a processing instruction node before the current node\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instructionBefore(target, value) {\n        var child, i, removed; // temporarily remove children starting *with* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i); // add the new child\n\n        child = this.parent.instruction(target, value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates a processing instruction node after the current node\n      // `target` instruction target\n      // `value` instruction value\n\n\n      instructionAfter(target, value) {\n        var child, i, removed; // temporarily remove children starting *after* this\n\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1); // add the new child\n\n        child = this.parent.instruction(target, value); // add back removed children after new child\n\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      } // Creates the xml declaration\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n\n\n      declaration(version, encoding, standalone) {\n        var doc, xmldec;\n        doc = this.document();\n        xmldec = new XMLDeclaration(doc, version, encoding, standalone); // Replace XML declaration if exists, otherwise insert at top\n\n        if (doc.children.length === 0) {\n          doc.children.unshift(xmldec);\n        } else if (doc.children[0].type === NodeType.Declaration) {\n          doc.children[0] = xmldec;\n        } else {\n          doc.children.unshift(xmldec);\n        }\n\n        return doc.root() || doc;\n      } // Creates the document type declaration\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n\n\n      dtd(pubID, sysID) {\n        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n        doc = this.document();\n        doctype = new XMLDocType(doc, pubID, sysID);\n        ref1 = doc.children; // Replace DTD if exists\n\n        for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n          child = ref1[i];\n\n          if (child.type === NodeType.DocType) {\n            doc.children[i] = doctype;\n            return doctype;\n          }\n        }\n\n        ref2 = doc.children; // insert before root node if the root node exists\n\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          child = ref2[i];\n\n          if (child.isRoot) {\n            doc.children.splice(i, 0, doctype);\n            return doctype;\n          }\n        } // otherwise append to end\n\n\n        doc.children.push(doctype);\n        return doctype;\n      } // Gets the parent node\n\n\n      up() {\n        if (this.isRoot) {\n          throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n        }\n\n        return this.parent;\n      } // Gets the root node\n\n\n      root() {\n        var node;\n        node = this;\n\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node.rootObject;\n          } else if (node.isRoot) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      } // Gets the node representing the XML document\n\n\n      document() {\n        var node;\n        node = this;\n\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      } // Ends the document and converts string\n\n\n      end(options) {\n        return this.document().end(options);\n      } // Gets the previous node\n\n\n      prev() {\n        var i;\n        i = this.parent.children.indexOf(this);\n\n        if (i < 1) {\n          throw new Error(\"Already at the first node. \" + this.debugInfo());\n        }\n\n        return this.parent.children[i - 1];\n      } // Gets the next node\n\n\n      next() {\n        var i;\n        i = this.parent.children.indexOf(this);\n\n        if (i === -1 || i === this.parent.children.length - 1) {\n          throw new Error(\"Already at the last node. \" + this.debugInfo());\n        }\n\n        return this.parent.children[i + 1];\n      } // Imports cloned root from another XML document\n      // `doc` the XML document to insert nodes from\n\n\n      importDocument(doc) {\n        var child, clonedRoot, j, len, ref1;\n        clonedRoot = doc.root().clone();\n        clonedRoot.parent = this;\n        clonedRoot.isRoot = false;\n        this.children.push(clonedRoot); // set properties if imported element becomes the root node\n\n        if (this.type === NodeType.Document) {\n          clonedRoot.isRoot = true;\n          clonedRoot.documentObject = this;\n          this.rootObject = clonedRoot; // set dtd name\n\n          if (this.children) {\n            ref1 = this.children;\n\n            for (j = 0, len = ref1.length; j < len; j++) {\n              child = ref1[j];\n\n              if (child.type === NodeType.DocType) {\n                child.name = clonedRoot.name;\n                break;\n              }\n            }\n          }\n        }\n\n        return this;\n      } // Returns debug string for this node\n\n\n      debugInfo(name) {\n        var ref1, ref2;\n        name = name || this.name;\n\n        if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n          return \"\";\n        } else if (name == null) {\n          return \"parent: <\" + this.parent.name + \">\";\n        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n          return \"node: <\" + name + \">\";\n        } else {\n          return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n        }\n      } // Aliases\n\n\n      ele(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      txt(value) {\n        return this.text(value);\n      }\n\n      dat(value) {\n        return this.cdata(value);\n      }\n\n      com(value) {\n        return this.comment(value);\n      }\n\n      ins(target, value) {\n        return this.instruction(target, value);\n      }\n\n      doc() {\n        return this.document();\n      }\n\n      dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n\n      e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      t(value) {\n        return this.text(value);\n      }\n\n      d(value) {\n        return this.cdata(value);\n      }\n\n      c(value) {\n        return this.comment(value);\n      }\n\n      r(value) {\n        return this.raw(value);\n      }\n\n      i(target, value) {\n        return this.instruction(target, value);\n      }\n\n      u() {\n        return this.up();\n      } // can be deprecated in a future release\n\n\n      importXMLBuilder(doc) {\n        return this.importDocument(doc);\n      } // Adds or modifies an attribute.\n      // `name` attribute name\n      // `value` attribute value\n\n\n      attribute(name, value) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      att(name, value) {\n        return this.attribute(name, value);\n      }\n\n      a(name, value) {\n        return this.attribute(name, value);\n      } // Removes an attribute\n      // `name` attribute name\n\n\n      removeAttribute(name) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      } // DOM level 1 functions to be implemented later\n\n\n      replaceChild(newChild, oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      removeChild(oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      appendChild(newChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      hasChildNodes() {\n        return this.children.length !== 0;\n      }\n\n      cloneNode(deep) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      normalize() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      } // DOM level 2\n\n\n      isSupported(feature, version) {\n        return true;\n      }\n\n      hasAttributes() {\n        return this.attribs.length !== 0;\n      } // DOM level 3 functions to be implemented later\n\n\n      compareDocumentPosition(other) {\n        var ref, res;\n        ref = this;\n\n        if (ref === other) {\n          return 0;\n        } else if (this.document() !== other.document()) {\n          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n\n          if (Math.random() < 0.5) {\n            res |= DocumentPosition.Preceding;\n          } else {\n            res |= DocumentPosition.Following;\n          }\n\n          return res;\n        } else if (ref.isAncestor(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Preceding;\n        } else if (ref.isDescendant(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Following;\n        } else if (ref.isPreceding(other)) {\n          return DocumentPosition.Preceding;\n        } else {\n          return DocumentPosition.Following;\n        }\n      }\n\n      isSameNode(other) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupPrefix(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isDefaultNamespace(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupNamespaceURI(prefix) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isEqualNode(node) {\n        var i, j, ref1;\n\n        if (node.nodeType !== this.nodeType) {\n          return false;\n        }\n\n        if (node.children.length !== this.children.length) {\n          return false;\n        }\n\n        for (i = j = 0, ref1 = this.children.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n          if (!this.children[i].isEqualNode(node.children[i])) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      getFeature(feature, version) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      setUserData(key, data, handler) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      getUserData(key) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      } // Returns true if other is an inclusive descendant of node,\n      // and false otherwise.\n\n\n      contains(other) {\n        if (!other) {\n          return false;\n        }\n\n        return other === this || this.isDescendant(other);\n      } // An object A is called a descendant of an object B, if either A is \n      // a child of B or A is a child of an object C that is a descendant of B.\n\n\n      isDescendant(node) {\n        var child, isDescendantChild, j, len, ref1;\n        ref1 = this.children;\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n\n          if (node === child) {\n            return true;\n          }\n\n          isDescendantChild = child.isDescendant(node);\n\n          if (isDescendantChild) {\n            return true;\n          }\n        }\n\n        return false;\n      } // An object A is called an ancestor of an object B if and only if\n      // B is a descendant of A.\n\n\n      isAncestor(node) {\n        return node.isDescendant(this);\n      } // An object A is preceding an object B if A and B are in the \n      // same tree and A comes before B in tree order.\n\n\n      isPreceding(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos < thisPos;\n        }\n      } // An object A is folllowing an object B if A and B are in the \n      // same tree and A comes after B in tree order.\n\n\n      isFollowing(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos > thisPos;\n        }\n      } // Returns the preorder position of the given node in the tree, or -1\n      // if the node is not in the tree.\n\n\n      treePosition(node) {\n        var found, pos;\n        pos = 0;\n        found = false;\n        this.foreachTreeNode(this.document(), function (childNode) {\n          pos++;\n\n          if (!found && childNode === node) {\n            return found = true;\n          }\n        });\n\n        if (found) {\n          return pos;\n        } else {\n          return -1;\n        }\n      } // Depth-first preorder traversal through the XML tree\n\n\n      foreachTreeNode(node, func) {\n        var child, j, len, ref1, res;\n        node || (node = this.document());\n        ref1 = node.children;\n\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n\n          if (res = func(child)) {\n            return res;\n          } else {\n            res = this.foreachTreeNode(child, func);\n\n            if (res) {\n              return res;\n            }\n          }\n        }\n      }\n\n    }\n\n    ; // DOM level 1\n\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function () {\n        return this.name;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function () {\n        return this.type;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function () {\n        return this.value;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function () {\n        return this.parent;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function () {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n\n        return this.childNodeList;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function () {\n        return this.children[0] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function () {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function () {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function () {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function () {\n        return this.document() || null;\n      }\n    }); // DOM level 3\n\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function () {\n        var child, j, len, ref1, str;\n\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function (value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n    return XMLNode;\n  }.call(this);\n}).call(this);","map":{"version":3,"sources":["/Users/tony_niu/Visual Studio/Twilio/twilio-video-starter-kit/node_modules/xmlbuilder/lib/XMLNode.js"],"names":["DocumentPosition","NodeType","XMLCData","XMLComment","XMLDeclaration","XMLDocType","XMLDummy","XMLElement","XMLNamedNodeMap","XMLNode","XMLNodeList","XMLProcessingInstruction","XMLRaw","XMLText","getValue","isEmpty","isFunction","isObject","hasProp","hasOwnProperty","splice","require","module","exports","constructor","parent1","parent","options","stringify","value","children","baseURI","setParent","child","j","len","ref1","results","length","push","element","name","attributes","text","childNode","item","k","key","lastChild","len1","val","Array","isArray","apply","call","ignoreDecorators","convertAttKey","indexOf","attribute","substr","separateArrayItems","dummy","keepNullNodes","convertTextKey","convertCDataKey","cdata","convertCommentKey","comment","convertRawKey","raw","convertPIKey","instruction","node","Error","debugInfo","insertBefore","i","newChild","refChild","removed","type","prototype","isRoot","insertAfter","remove","concat","commentBefore","commentAfter","target","insTarget","insValue","instructionBefore","instructionAfter","declaration","version","encoding","standalone","doc","xmldec","document","unshift","Declaration","root","dtd","pubID","sysID","doctype","ref2","DocType","up","Document","rootObject","end","prev","next","importDocument","clonedRoot","clone","documentObject","ele","nod","txt","dat","com","ins","dec","e","n","t","d","c","r","u","importXMLBuilder","att","a","removeAttribute","replaceChild","oldChild","removeChild","appendChild","hasChildNodes","cloneNode","deep","normalize","isSupported","feature","hasAttributes","attribs","compareDocumentPosition","other","ref","res","Disconnected","ImplementationSpecific","Math","random","Preceding","Following","isAncestor","Contains","isDescendant","isPreceding","isSameNode","lookupPrefix","namespaceURI","isDefaultNamespace","lookupNamespaceURI","prefix","isEqualNode","nodeType","getFeature","setUserData","data","handler","getUserData","contains","isDescendantChild","nodePos","thisPos","treePosition","isFollowing","found","pos","foreachTreeNode","func","Object","defineProperty","get","childNodeList","nodes","str","Element","DocumentFragment","textContent","set"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject,\n    hasProp = {}.hasOwnProperty,\n    splice = [].splice;\n\n  ({isObject, isFunction, isEmpty, getValue} = require('./Utility'));\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  XMLProcessingInstruction = null;\n\n  XMLDummy = null;\n\n  NodeType = null;\n\n  XMLNodeList = null;\n\n  XMLNamedNodeMap = null;\n\n  DocumentPosition = null;\n\n  // Represents a generic XMl element\n  module.exports = XMLNode = (function() {\n    class XMLNode {\n      // Initializes a new instance of `XMLNode`\n\n      // `parent` the parent node\n      constructor(parent1) {\n        this.parent = parent1;\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n        this.value = null;\n        this.children = [];\n        this.baseURI = null;\n        // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      }\n\n      \n      // Sets the parent node of this node and its children recursively\n\n      // `parent` the parent node\n      setParent(parent) {\n        var child, j, len, ref1, results;\n        this.parent = parent;\n        if (parent) {\n          this.options = parent.options;\n          this.stringify = parent.stringify;\n        }\n        ref1 = this.children;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          results.push(child.setParent(this));\n        }\n        return results;\n      }\n\n      // Creates a child element node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      element(name, attributes, text) {\n        var childNode, item, j, k, key, lastChild, len, len1, val;\n        lastChild = null;\n        if (attributes === null && (text == null)) {\n          [attributes, text] = [{}, null];\n        }\n        if (attributes == null) {\n          attributes = {};\n        }\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        if (name != null) {\n          name = getValue(name);\n        }\n        // expand if array\n        if (Array.isArray(name)) {\n          for (j = 0, len = name.length; j < len; j++) {\n            item = name[j];\n            lastChild = this.element(item);\n          }\n        // evaluate if function\n        } else if (isFunction(name)) {\n          lastChild = this.element(name.apply());\n        // expand if object\n        } else if (isObject(name)) {\n          for (key in name) {\n            if (!hasProp.call(name, key)) continue;\n            val = name[key];\n            if (isFunction(val)) {\n              // evaluate if function\n              val = val.apply();\n            }\n            // assign attributes\n            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n            // skip empty arrays\n            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n              lastChild = this.dummy();\n            // empty objects produce one node\n            } else if (isObject(val) && isEmpty(val)) {\n              lastChild = this.element(key);\n            // skip null and undefined nodes\n            } else if (!this.options.keepNullNodes && (val == null)) {\n              lastChild = this.dummy();\n            \n            // expand list by creating child nodes\n            } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n              for (k = 0, len1 = val.length; k < len1; k++) {\n                item = val[k];\n                childNode = {};\n                childNode[key] = item;\n                lastChild = this.element(childNode);\n              }\n            \n            // expand child nodes under parent\n            } else if (isObject(val)) {\n              // if the key is #text expand child nodes under this node to support mixed content\n              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                lastChild = this.element(val);\n              } else {\n                lastChild = this.element(key);\n                lastChild.element(val);\n              }\n            } else {\n              \n              // text node\n              lastChild = this.element(key, val);\n            }\n          }\n        // skip null nodes\n        } else if (!this.options.keepNullNodes && text === null) {\n          lastChild = this.dummy();\n        } else {\n          // text node\n          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n            lastChild = this.text(text);\n          // cdata node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n            lastChild = this.cdata(text);\n          // comment node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n            lastChild = this.comment(text);\n          // raw text node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n            lastChild = this.raw(text);\n          // processing instruction\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n          } else {\n            // element node\n            lastChild = this.node(name, attributes, text);\n          }\n        }\n        if (lastChild == null) {\n          throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n        }\n        return lastChild;\n      }\n\n      // Creates a child element node before the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertBefore(name, attributes, text) {\n        var child, i, newChild, refChild, removed;\n        // DOM level 1\n        // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n        if (name != null ? name.type : void 0) {\n          newChild = name;\n          refChild = attributes;\n          newChild.setParent(this);\n          if (refChild) {\n            // temporarily remove children starting *with* refChild\n            i = children.indexOf(refChild);\n            removed = children.splice(i);\n            \n            // add the new child\n            children.push(newChild);\n            \n            // add back removed children after new child\n            Array.prototype.push.apply(children, removed);\n          } else {\n            children.push(newChild);\n          }\n          return newChild;\n        } else {\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          }\n          \n          // temporarily remove children starting *with* this\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i);\n          \n          // add the new child\n          child = this.parent.element(name, attributes, text);\n          \n          // add back removed children after new child\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        }\n      }\n\n      // Creates a child element node after the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertAfter(name, attributes, text) {\n        var child, i, removed;\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        }\n        \n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        \n        // add the new child\n        child = this.parent.element(name, attributes, text);\n        \n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      }\n\n      // Deletes a child element node\n\n      remove() {\n        var i, ref1;\n        if (this.isRoot) {\n          throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n        }\n        i = this.parent.children.indexOf(this);\n        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n        return this.parent;\n      }\n\n      // Creates a node\n\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      node(name, attributes, text) {\n        var child;\n        if (name != null) {\n          name = getValue(name);\n        }\n        attributes || (attributes = {});\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        child = new XMLElement(this, name, attributes);\n        if (text != null) {\n          child.text(text);\n        }\n        this.children.push(child);\n        return child;\n      }\n\n      // Creates a text node\n\n      // `value` element text\n      text(value) {\n        var child;\n        if (isObject(value)) {\n          this.element(value);\n        }\n        child = new XMLText(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a CDATA node\n\n      // `value` element text without CDATA delimiters\n      cdata(value) {\n        var child;\n        child = new XMLCData(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node\n\n      // `value` comment text\n      comment(value) {\n        var child;\n        child = new XMLComment(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node before the current node\n\n      // `value` comment text\n      commentBefore(value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a comment node after the current node\n\n      // `value` comment text\n      commentAfter(value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Adds unescaped raw text\n\n      // `value` text\n      raw(value) {\n        var child;\n        child = new XMLRaw(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Adds a dummy node\n      dummy() {\n        var child;\n        child = new XMLDummy(this);\n        // Normally when a new node is created it is added to the child node collection.\n        // However, dummy nodes are never added to the XML tree. They are created while\n        // converting JS objects to XML nodes in order not to break the recursive function\n        // chain. They can be thought of as invisible nodes. They can be traversed through\n        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n\n        // @children.push child\n        return child;\n      }\n\n      // Adds a processing instruction\n\n      // `target` instruction target\n      // `value` instruction value\n      instruction(target, value) {\n        var insTarget, insValue, instruction, j, len;\n        if (target != null) {\n          target = getValue(target);\n        }\n        if (value != null) {\n          value = getValue(value);\n        }\n        if (Array.isArray(target)) { // expand if array\n          for (j = 0, len = target.length; j < len; j++) {\n            insTarget = target[j];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) { // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n          instruction = new XMLProcessingInstruction(this, target, value);\n          this.children.push(instruction);\n        }\n        return this;\n      }\n\n      // Creates a processing instruction node before the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionBefore(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a processing instruction node after the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionAfter(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates the xml declaration\n\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n      declaration(version, encoding, standalone) {\n        var doc, xmldec;\n        doc = this.document();\n        xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n        // Replace XML declaration if exists, otherwise insert at top\n        if (doc.children.length === 0) {\n          doc.children.unshift(xmldec);\n        } else if (doc.children[0].type === NodeType.Declaration) {\n          doc.children[0] = xmldec;\n        } else {\n          doc.children.unshift(xmldec);\n        }\n        return doc.root() || doc;\n      }\n\n      // Creates the document type declaration\n\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n      dtd(pubID, sysID) {\n        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n        doc = this.document();\n        doctype = new XMLDocType(doc, pubID, sysID);\n        ref1 = doc.children;\n        // Replace DTD if exists\n        for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n          child = ref1[i];\n          if (child.type === NodeType.DocType) {\n            doc.children[i] = doctype;\n            return doctype;\n          }\n        }\n        ref2 = doc.children;\n        // insert before root node if the root node exists\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          child = ref2[i];\n          if (child.isRoot) {\n            doc.children.splice(i, 0, doctype);\n            return doctype;\n          }\n        }\n        // otherwise append to end\n        doc.children.push(doctype);\n        return doctype;\n      }\n\n      // Gets the parent node\n      up() {\n        if (this.isRoot) {\n          throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n        }\n        return this.parent;\n      }\n\n      // Gets the root node\n      root() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node.rootObject;\n          } else if (node.isRoot) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Gets the node representing the XML document\n      document() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Ends the document and converts string\n      end(options) {\n        return this.document().end(options);\n      }\n\n      // Gets the previous node\n      prev() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i < 1) {\n          throw new Error(\"Already at the first node. \" + this.debugInfo());\n        }\n        return this.parent.children[i - 1];\n      }\n\n      // Gets the next node\n      next() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i === -1 || i === this.parent.children.length - 1) {\n          throw new Error(\"Already at the last node. \" + this.debugInfo());\n        }\n        return this.parent.children[i + 1];\n      }\n\n      // Imports cloned root from another XML document\n\n      // `doc` the XML document to insert nodes from\n      importDocument(doc) {\n        var child, clonedRoot, j, len, ref1;\n        clonedRoot = doc.root().clone();\n        clonedRoot.parent = this;\n        clonedRoot.isRoot = false;\n        this.children.push(clonedRoot);\n        // set properties if imported element becomes the root node\n        if (this.type === NodeType.Document) {\n          clonedRoot.isRoot = true;\n          clonedRoot.documentObject = this;\n          this.rootObject = clonedRoot;\n          // set dtd name\n          if (this.children) {\n            ref1 = this.children;\n            for (j = 0, len = ref1.length; j < len; j++) {\n              child = ref1[j];\n              if (child.type === NodeType.DocType) {\n                child.name = clonedRoot.name;\n                break;\n              }\n            }\n          }\n        }\n        return this;\n      }\n\n      \n      // Returns debug string for this node\n      debugInfo(name) {\n        var ref1, ref2;\n        name = name || this.name;\n        if ((name == null) && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n          return \"\";\n        } else if (name == null) {\n          return \"parent: <\" + this.parent.name + \">\";\n        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n          return \"node: <\" + name + \">\";\n        } else {\n          return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n        }\n      }\n\n      // Aliases\n      ele(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      txt(value) {\n        return this.text(value);\n      }\n\n      dat(value) {\n        return this.cdata(value);\n      }\n\n      com(value) {\n        return this.comment(value);\n      }\n\n      ins(target, value) {\n        return this.instruction(target, value);\n      }\n\n      doc() {\n        return this.document();\n      }\n\n      dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n\n      e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      t(value) {\n        return this.text(value);\n      }\n\n      d(value) {\n        return this.cdata(value);\n      }\n\n      c(value) {\n        return this.comment(value);\n      }\n\n      r(value) {\n        return this.raw(value);\n      }\n\n      i(target, value) {\n        return this.instruction(target, value);\n      }\n\n      u() {\n        return this.up();\n      }\n\n      // can be deprecated in a future release\n      importXMLBuilder(doc) {\n        return this.importDocument(doc);\n      }\n\n      // Adds or modifies an attribute.\n\n      // `name` attribute name\n      // `value` attribute value\n      attribute(name, value) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      att(name, value) {\n        return this.attribute(name, value);\n      }\n\n      a(name, value) {\n        return this.attribute(name, value);\n      }\n\n      // Removes an attribute\n\n      // `name` attribute name\n      removeAttribute(name) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      // DOM level 1 functions to be implemented later\n      replaceChild(newChild, oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      removeChild(oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      appendChild(newChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      hasChildNodes() {\n        return this.children.length !== 0;\n      }\n\n      cloneNode(deep) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      normalize() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // DOM level 2\n      isSupported(feature, version) {\n        return true;\n      }\n\n      hasAttributes() {\n        return this.attribs.length !== 0;\n      }\n\n      // DOM level 3 functions to be implemented later\n      compareDocumentPosition(other) {\n        var ref, res;\n        ref = this;\n        if (ref === other) {\n          return 0;\n        } else if (this.document() !== other.document()) {\n          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n          if (Math.random() < 0.5) {\n            res |= DocumentPosition.Preceding;\n          } else {\n            res |= DocumentPosition.Following;\n          }\n          return res;\n        } else if (ref.isAncestor(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Preceding;\n        } else if (ref.isDescendant(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Following;\n        } else if (ref.isPreceding(other)) {\n          return DocumentPosition.Preceding;\n        } else {\n          return DocumentPosition.Following;\n        }\n      }\n\n      isSameNode(other) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupPrefix(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isDefaultNamespace(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupNamespaceURI(prefix) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isEqualNode(node) {\n        var i, j, ref1;\n        if (node.nodeType !== this.nodeType) {\n          return false;\n        }\n        if (node.children.length !== this.children.length) {\n          return false;\n        }\n        for (i = j = 0, ref1 = this.children.length - 1; (0 <= ref1 ? j <= ref1 : j >= ref1); i = 0 <= ref1 ? ++j : --j) {\n          if (!this.children[i].isEqualNode(node.children[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      getFeature(feature, version) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      setUserData(key, data, handler) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      getUserData(key) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // Returns true if other is an inclusive descendant of node,\n      // and false otherwise.\n      contains(other) {\n        if (!other) {\n          return false;\n        }\n        return other === this || this.isDescendant(other);\n      }\n\n      // An object A is called a descendant of an object B, if either A is \n      // a child of B or A is a child of an object C that is a descendant of B.\n      isDescendant(node) {\n        var child, isDescendantChild, j, len, ref1;\n        ref1 = this.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (node === child) {\n            return true;\n          }\n          isDescendantChild = child.isDescendant(node);\n          if (isDescendantChild) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // An object A is called an ancestor of an object B if and only if\n      // B is a descendant of A.\n      isAncestor(node) {\n        return node.isDescendant(this);\n      }\n\n      // An object A is preceding an object B if A and B are in the \n      // same tree and A comes before B in tree order.\n      isPreceding(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos < thisPos;\n        }\n      }\n\n      // An object A is folllowing an object B if A and B are in the \n      // same tree and A comes after B in tree order.\n      isFollowing(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos > thisPos;\n        }\n      }\n\n      // Returns the preorder position of the given node in the tree, or -1\n      // if the node is not in the tree.\n      treePosition(node) {\n        var found, pos;\n        pos = 0;\n        found = false;\n        this.foreachTreeNode(this.document(), function(childNode) {\n          pos++;\n          if (!found && childNode === node) {\n            return found = true;\n          }\n        });\n        if (found) {\n          return pos;\n        } else {\n          return -1;\n        }\n      }\n\n      \n      // Depth-first preorder traversal through the XML tree\n      foreachTreeNode(node, func) {\n        var child, j, len, ref1, res;\n        node || (node = this.document());\n        ref1 = node.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (res = func(child)) {\n            return res;\n          } else {\n            res = this.foreachTreeNode(child, func);\n            if (res) {\n              return res;\n            }\n          }\n        }\n      }\n\n    };\n\n    // DOM level 1\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function() {\n        return this.type;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function() {\n        return this.value;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function() {\n        return this.parent;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function() {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n        return this.childNodeList;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function() {\n        return this.children[0] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function() {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function() {\n        return this.document() || null;\n      }\n    });\n\n    // DOM level 3\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function() {\n        var child, j, len, ref1, str;\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function(value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    return XMLNode;\n\n  }).call(this);\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}